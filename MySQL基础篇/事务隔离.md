# 事务隔离

事务的四大特性 ACID，分别是原子性、一致性、隔离性和持久性，其中隔离性是事务的基本特性之一，它可以防止数据库在并发处理时出现数据不一致的情况。最严格的情况下，我们可以采用串行化的方式来执行每一个事务，这就意味着事务之间是相互独立的，不存在并发的情况。然而在实际生产环境下，考虑到随着用户量的增多，会存在大规模并发访问的情况，这就要求数据库有更高的吞吐能力，这个时候串行化的方式就无法满足数据库高并发访问的需求，我们还需要降低数据库的隔离标准，来换取事务之间的并发能力。


### 事务并发存在的异常

*   __脏读__

    读到了其他事务还没有提交的数据。
    
    举个例子，我们现在开了两个客户端分别操作 数据表 test，"客户端1" 对 test 表进行了查询，他查到数据表里面一共有一个 数据列name 值为 "张三"，但是此时如果 "客户端2" 现在启动了一个事务，他现在insert 了一个新的名称 "李四",此时 "客户端2" 还未提交事务(__事务隔离级别为读未提交__)，但是此时如果 "客户端1" 再进行 select * from test 他会看到 "李四" 这个名字。


*   __不可重复读__

    对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。

    举个例子，此时还是有两个客户端分别操作数据表 test，"客户端1" 对 test 表进行了查询，他查到数据表里面一共有一个 数据列name 值为 "张三"，但是此时如果 "客户端2" 现在启动了一个事务，他准备修改 "张三" 这个名字为 "张麻子" ，此时事务未提交 (__事务隔离级别为读未提交__)，那么 "客户端1" 再进行 select  * from test  他会看到 "张麻子" 这条数据，但是已经没有 "张三" 这个名字了。

*   __幻读__

    事务 A 根据条件查询得到了 N 条数据，但此时事务 B 更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候发现会有 N+M 条数据，产生了幻读(__事务隔离级别为读未提交__)。

    举个例子，如别人删除了数据 但是自己在读时自己这里却没有发生变化 当自己也提交了事务 没有修改别人修改的数据，提交之后 再次读取时别人删掉的数据就不见了，但是自己又没有修改数据 让人感觉产生了幻觉 即为幻读

    __幻读要解决的话，需要添加范围锁RangeS，就是锁定检锁范围为只读__

*   __幻读和不可重复读的区别__

    幻读和不可重复度很相似，举个例子，幻读就是同一个事务A，多次查询返回的"结果集"不同 (结果集，这里指的是符合某一条件的数据范围)，数据可能多了也可能少了。原因是因为事务B对结果集做了INSERT或者UPDATE，或者DELETE。

    不可重复度是因为对同一条记录做了修改，也就是针对某一个记录进行的UPDATE或者DELETE

    事务B进行DELETE或者UPDATE的时候，事务A 如果是 __查询同一条记录就是__ 不可重复度。如果 __查询的是某一个范围就是__ 幻读。举个例子，比如 你想要查找 分数大于60的学生，这时你UPDATE 某个59分的人 到61分，然后再查询 分数大于60的学生，就发现多了一个人，所以事务B的作用是 对查询结果集起到影响了，所以会产生幻读，DELETE同理。

*   __个人理解__
    
    假如我提交一个事务，然后读取 test表中id为1的name值，此时我读取到了 张三，但是这个时候用户B修改了 张三这个值为 李四，这个时候如果是 读已提交的情况，就会出现不可重复度，但是如果是可重复度的情况，那就会给我们现在正在查询的值加上锁，因为我们之前提交了事务，然后进行读取，只有在我们关闭这个事务之后，才允许修改这个值。


### 事务隔离级别

解决异常数量从少到多的顺序（比如读未提交可能存在 3 种异常，可串行化则不会存在这些异常）决定了隔离级别的高低，这四种隔离级别从低到高分别是：读未提交（READ UNCOMMITTED ）、读已提交（READ COMMITTED）、可重复读（REPEATABLE READ）和可串行化（SERIALIZABLE）。这些隔离级别能解决的异常情况如下表所示：


<div align=center><img  src="https://raw.githubusercontent.com/OneStepAndTwoSteps/SQL-Notes/master/static/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/1.png"/></div>


*   __读未提交（READ UNCOMMITTED ）__

    读未提交，也就是允许读到未提交的数据，这种情况下查询是不会使用锁的，可能会产生脏读、不可重复读、幻读等情况。

    在这个隔离级别下，事务A会读到事务B未提交的数据，在事务B回滚后，事务A读到的数据无意义，是脏数据，称为 脏读

*   __读已提交（READ COMMITTED）__

    读已提交就是只能读到已经提交的内容，可以避免脏读的产生，属于 RDBMS 中常见的默认隔离级别（比如说 Oracle 和 SQL Server），但如果想要避免不可重复读或者幻读，就需要我们在 SQL 查询的时候编写带加锁的 SQL 语句。

    在这个隔离级别下，只有在事务B已提交时，事务A才能读到，如果事务A先查询id为1的记录，之后事务B修改这条记录并提交，事务A再读取，两次结果会不一致，所以不可重复读。

*   __可重复读（REPEATABLE READ）__

    可重复读，保证一个事务在相同查询条件下两次查询得到的数据结果是一致的，可以避免不可重复读和脏读，但无法避免幻读。__MySQL 默认的隔离级别就是可重复读。__

    在这个隔离级别下，就算事务B的修改已经提交，事务A读到的数据依旧是一致的。当事务B插入一条新数据并提交之后，事务A查询不到当前数据，查询不到就以为不存在，但是事务A却可以更新这条数据成功，并且更新后再次查询，数据出现了。一开始查询不到，但再次查询又出现了，跟幻觉一样，所以称为　幻读。

*   __可串行化（SERIALIZABLE）__


    可串行化，将事务进行串行化，也就是在一个队列中按照顺序执行，可串行化是最高级别的隔离等级，可以解决事务读取中所有可能出现的异常情况，但是它牺牲了系统的并发性。



#### 查看当前事务隔离级别

    mysql> SHOW VARIABLES LIKE 'transaction_isolation';

    mariadb> select @@tx_isolation;


#### 设置当前事务隔离级别

    mysql> SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;




### 小结



事务的并发异常我们可以通过设置不同的事务级别进行解决，__正确性：只要能满足某一个隔离级别，一定能解决这个隔离级别对应的异常问题。__

隔离级别越低，意味着系统吞吐量（并发程度）越大，但同时也意味着出现异常问题的可能性会更大。在实际使用过程中我们往往需要在性能和正确性上进行权衡和取舍，没有完美的解决方案，只有适合与否。


