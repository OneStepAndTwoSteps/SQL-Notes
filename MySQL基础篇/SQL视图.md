# SQL 视图

#### 什么是视图？

视图作为一张虚拟表，帮我们封装了底层与数据表的接口。它相当于是一张表或多张表的数据结果集。视图的这一特点，可以帮我们简化复杂的 SQL 查询，比如在编写视图后，我们就可以直接重用它，而不需要考虑视图中包含的基础查询的细节。同样，我们也可以根据需要更改数据格式，返回与底层数据表格式不同的数据。

这里我们要注意的是，视图是虚拟表，本身不存储数据，如果想要通过视图对底层数据表的数据进行修改也会受到很多限制，__通常我们是把视图用于查询，也就是对 SQL 查询的一种封装。__

#### 使用场景之一

视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。


## 操作视图

### 创建视图

语法：

    CREATE VIEW view_name(视图名称) AS
    SELECT column_name1(列名), column_name2(列名)
    FROM table(从那张表读数据)
    WHERE condition(条件)

例子：

    查询team_id为1001的所有队员的 player_id 和 player_name,将数据保存到视图中

        MariaDB [sql_notes]> CREATE VIEW NBA1001 AS SELECT player_id,player_name FROM player LEFT JOIN  team ON player.team_id=team.team_id ;
        Query OK, 0 rows affected (0.00 sec)

__查看视图中的数据和查看table一样，如__

    SELECT * FROM NBA1001;

__同时创建视图时支持我们在之前的视图的基础上进行创建__

比如我们现在只想拿前五位player，创建一个新的视图

    MariaDB [sql_notes]> CREATE VIEW NBA2 AS SELECT * FROM NBA1001 LIMIT 5;
    Query OK, 0 rows affected (0.00 sec)


    MariaDB [sql_notes]> select * from NBA2;

    +-----------+------------------------+
    | player_id | player_name            |
    +-----------+------------------------+
    |     10001 | 韦恩-艾灵顿            |
    |     10002 | 雷吉-杰克逊            |
    |     10003 | 安德烈-德拉蒙德        |
    |     10004 | 索恩-马克              |
    |     10005 | 布鲁斯-布朗            |
    +-----------+------------------------+
    5 rows in set (0.00 sec)

### 更新视图

更新视图，也就是在视图上执行INSERT、DELETE、UPDATE语句，但是 __对视图执行更新语句的本质上是对该视图对应的底层表进行更新!!!__

__1、比如我现在创建了一个视图__

    CREATE VIEW NBA2_VIEW AS SELECT * FROM player ;

    MariaDB [sql_notes]> SELECT * FROM NBA2_VIEW;
    +-----------+---------+------------------------------------+--------+
    | player_id | team_id | player_name                        | height |
    +-----------+---------+------------------------------------+--------+
    |     10001 |    1001 | 韦恩-艾灵顿                        |   1.93 |
    |     10002 |    1001 | 雷吉-杰克逊                        |   1.91 |
    |     10003 |    1001 | 安德烈-德拉蒙德                    |   2.12 |
    |     10004 |    1001 | 索恩-马克                          |   2.16 |
    |     10005 |    1001 | 布鲁斯-布朗                        |   1.96 |
    |     10006 |    1001 | 兰斯顿-加洛韦                      |   1.88 |
    |     10007 |    1001 | 格伦-罗宾逊三世                    |   1.98 |

           ...      ....    .....                                ....

__2、现在对视图进行更新__

    UPDATE NBA2_VIEW SET player_name='player1' WHERE player_id=10001;


__3、查看底层的表，发现确实修改了原有的表的数据__

    MariaDB [sql_notes]> SELECT * FROM player;
    +-----------+---------+------------------------------------+--------+
    | player_id | team_id | player_name                        | height |
    +-----------+---------+------------------------------------+--------+
    |     10001 |    1001 | player1                            |   1.93 |
    |     10002 |    1001 | 雷吉-杰克逊                        |   1.91 |
    |     10003 |    1001 | 安德烈-德拉蒙德                    |   2.12 |


#### 注意

不过并不是可以在所有的视图上执行更新语句的，在生成视图的时候使用了下边这些语句的都不能进行更新：

    1、分组

    2、连接查询

    3、子查询

    4、组合查询

    5、聚集函数

    6、DISTINCT

    7、查询列表上是非列名的表达式


__一般情况下，我们只在视图上执行查询操作而不进行更新操作！所以不要在视图进行更新操作!!!!__


### 修改视图

    比如我们现在想在之前的NBA2视图的基础上加上team_name

    MariaDB [sql_notes]> ALTER VIEW NBA1001 AS SELECT player_id,player_name,team_name FROM player LEFT JOIN  team ON player.team_id=team.team_id LIMIT 5;
    Query OK, 0 rows affected (0.01 sec)

    MariaDB [sql_notes]> select * from NBA1001;
    +-----------+------------------------+-----------------+
    | player_id | player_name            | team_name       |
    +-----------+------------------------+-----------------+
    |     10001 | 韦恩-艾灵顿            | 底特律活塞      |
    |     10002 | 雷吉-杰克逊            | 底特律活塞      |
    |     10003 | 安德烈-德拉蒙德        | 底特律活塞      |
    |     10004 | 索恩-马克              | 底特律活塞      |
    |     10005 | 布鲁斯-布朗            | 底特律活塞      |
    +-----------+------------------------+-----------------+



### 删除视图

    DROP VIEW view_name;


### 对视图数据进行格式化

比如我们现在想在修改之后的NBA1001的基础之上将 team_name 和 player_name 组合成同一列 如 韦恩-艾灵顿(底特律活塞)

    CREATE VIEW NBA3 AS SELECT player_id,CONCAT(player_name,'(',team_name,')') AS player_and_team  FROM NBA1001;
    Query OK, 0 rows affected (0.00 sec)

    MariaDB [sql_notes]> SELECT * FROM NBA3;
    +-----------+-----------------------------------------+
    | player_id | player_and_team                         |
    +-----------+-----------------------------------------+
    |     10001 | 韦恩-艾灵顿(底特律活塞)                 |
    |     10002 | 雷吉-杰克逊(底特律活塞)                 |
    |     10003 | 安德烈-德拉蒙德(底特律活塞)             |
    |     10004 | 索恩-马克(底特律活塞)                   |
    |     10005 | 布鲁斯-布朗(底特律活塞)                 |
    +-----------+-----------------------------------------+
    5 rows in set (0.00 sec)


### 在视图中进行运算


如果我想要统计每位球员在每场比赛中的二分球、三分球和罚球的得分，可以通过创建视图完成：

shoot_hits 投篮命中次数 shoot_3_hits 三分球命中次数 shoot_p_hits 罚球命中次数 

    CREATE VIEW game_player_score AS
    SELECT game_id, player_id, (shoot_hits-shoot_3_hits)*2 AS shoot_2_points, shoot_3_hits*3 AS shoot_3_points, shoot_p_hits AS shoot_p_points, score  FROM player_score


    MariaDB [sql_notes]> SELECT * FROM game_player_score;
    +---------+-----------+----------------+----------------+----------------+-------+
    | game_id | player_id | shoot_2_points | shoot_3_points | shoot_p_points | score |
    +---------+-----------+----------------+----------------+----------------+-------+
    |   10001 |     10001 |             12 |             12 |              2 |    26 |
    |   10001 |     10002 |             14 |              3 |              5 |    22 |
    |   10001 |     10003 |             16 |              0 |              2 |    18 |
    |   10001 |     10004 |              0 |             12 |              2 |    14 |
    |   10001 |     10005 |              0 |              0 |              0 |     0 |
    |   10001 |     10006 |              2 |              6 |              1 |     9 |
    |   10001 |     10007 |              2 |              3 |              2 |     7 |
    |   10001 |     10008 |              6 |              0 |              0 |     6 |
    |   10001 |     10009 |              0 |              0 |              0 |     0 |
    |   10001 |     10010 |              0 |              0 |              0 |     0 |
    |   10002 |     10022 |             12 |              3 |              4 |    19 |
    |   10002 |     10025 |             16 |              0 |              3 |    19 |
    |   10002 |     10024 |              6 |              6 |              5 |    17 |
    |   10002 |     10028 |              0 |             12 |              1 |    13 |
    |   10002 |     10030 |              4 |              0 |              0 |     4 |
    |   10002 |     10023 |             16 |              0 |              2 |    18 |
    |   10002 |     10029 |              8 |              3 |              0 |    11 |
    |   10002 |     10031 |              2 |              6 |              2 |    10 |
    |   10002 |     10032 |              0 |              0 |              0 |     0 |
    +---------+-----------+----------------+----------------+----------------+-------+
    19 rows in set (0.00 sec)


## 总结

视图是虚拟表，本身不存储数据，如果想要通过视图对底层数据表的数据进行修改也会受到很多限制，通常我们是把视图用于查询，也就是对 SQL 查询的一种封装。

__安全性：__ 

虚拟表是基于底层数据表的，如果想要通过视图对底层数据表的数据进行修改也会受到很多限制，比如无法进行字段类型转换，在 __一定程度上__ 保证了安全性。同时，我们还可以针对不同用户开放不同的数据查询权限，比如人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。

__简单清晰：__

视图是对 SQL 查询的封装，它可以将原本复杂的 SQL 查询简化，在编写好查询之后，我们就可以直接重用它而不必要知道基本的查询细节。同时我们还可以在视图之上再嵌套视图。这样就好比我们在进行模块化编程一样，不仅结构清晰，还提升了代码的复用率。

__一个视图其实是SELECT语句的集合，执行时会提前编译好，可以反复使用。在底层执行顺序的时候和SELECT语句是一样。__


### 重点

视图其实就是某个查询的别名，而不是某个查询的结果集，换句话说就是，创建视图的时候并不会把那个又臭又长的查询语句的结果集维护在硬盘或者内存里！在对视图进行查询时，MySQL服务器将会帮助我们把对视图的查询语句转换为对底层表的查询语句然后再执行.



## 补充

### 虚拟表和临时表的区别

在实际工作中，我们可能会见到各种临时数据。比如你可能会问，如果我在做一个电商的系统，中间会有个购物车的功能，需要临时统计购物车中的商品和金额，那该怎么办呢？这里就需要用到临时表了，临时表是真实存在的数据表，不过它不用于长期存放数据，只为当前连接存在，__关闭连接后，临时表就会自动释放。__

