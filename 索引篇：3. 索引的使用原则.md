# 索引的使用原则

*   一、什么是时候使用索引？

*   二、索引不是万能的，那么什么时候不使用索引？

*   三、创建了索引不一定代表能用得上，那么什么时候索引会失效？


## 一、创建索引的规律：

创建索引是有规律可循的，当这些规律出现表示我们可以考虑创建索引了：


__1、字段的数值有唯一性的限制，比如用户名__

*   索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在我们的数据表中，如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。

__2、频繁作为 WHERE 查询条件的字段，尤其在数据表大的情况下__
    
*   在数据量大的情况下，某个字段在 SQL 查询的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。创建普通索引就可以大幅提升数据查询的效率。

__3、需要经常 GROUP BY 和 ORDER BY 的列__

*   索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。

*   注意：当我们在一个搜索语句中同时用到 GROUP BY 和 ORDER BY 时，如：

        SELECT user_id,count(*) as num FROM produce_comment GROUP BY user_id ORDER BY comment_time desc limit 100
    
*   我们即使为 user_id 和 comment_time 分别加上索引速度也不会有太大的提升，

*   实际上多个单列索引在多条件查询时只会生效一个索引（MySQL 会选择其中一个限制最严格的作为索引），所以在 __多条件联合查询的时候最好创建联合索引__ 。

*   如果我们创建联合索引的顺序为 (comment_time, user_id) 呢？运行时间为 1.990s，同样比两个单列索引要快，但是会比顺序为 (user_id, comment_time) 的索引要慢一些(查询时间为 0.775s)。
    
*   这是因为在进行 SELECT 查询的时候，先进行 GROUP BY，再对数据进行 ORDER BY 的操作，所以按照这个联合索引的顺序效率是最高的。

__4、UPDATE、DELETE 的 WHERE 条件列，一般也需要创建索引__


*   在当我们对某条数据进行 UPDATE 或者 DELETE 操作的时候，是也需要对 WHERE 的条件列创建索引。

*   对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率，如。

        
        UPDATE product_comment SET product_id = 10001 WHERE comment_text = '462eed7ac6e791292a79'

        创建索引前：运行结果为 Affected rows: 1，运行时间为 1.173s。
    
        创建索引后：对 comment_text 创建了索引，再来执行这条 SQL 语句，运行时间仅为 0.1110s。

*   之所以能提升搜索速度的原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。
    
*   如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。

*   __注意：__ 我们也需要注意平衡，如果索引太多了，在更新数据的时候，如果涉及到索引更新，就会造成负担。

__5、DISTINCT 字段需要创建索引__

*   有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率

*   因为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多

__6、做多表 JOIN 连接操作时，创建索引需要注意以下的原则__

*   1、连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。   

*   2、对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的

*   3、对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。比如 user_id 在 product_comment 表和 user 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。


        SELECT comment_id, comment_text, product_comment.user_id, user_name FROM product_comment \ 
        JOIN user ON product_comment.user_id = user.user_id WHERE comment_text = '462eed7ac6e791292a79'

        只对 user_id 创建索引，执行 SQL 语句：运行时间 0.810s

        对 comment_text 创建索引，再执行上面的 SQL 语句，运行时间为 0.046s

*   如果我们不使用 WHERE 条件查询，而是直接采用 JOIN…ON…进行连接的话，即使使用了各种优化手段，总的运行时间也会很长（>100s）


## 二、什么时候不需要创建索引

*   __第一种情况：WHERE 条件（包括 GROUP BY、ORDER BY）里用不到的字段不需要创建索引。__
    
    索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。

*   __第二种情况：如果表记录太少，比如少于 1000 个，那么是不需要创建索引的__


*   __第三种情况是，字段中如果有大量重复数据，也不用创建索引，比如性别字段__

    对于重复数据，我们还需要结合数量的分布情况来判断是否创建索引。

*   __最后一种情况是，频繁更新的字段不一定要创建索引。__
    
    因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。


## 三、什么情况下索引失效

*   __1、如果索引进行了表达式计算，则会失效__，如：

    
        EXPLAIN SELECT comment_id, user_id, comment_text FROM product_comment WHERE comment_id+1 = 900001
    
    运行结果：

        +----+-------------+-----------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
        | id | select_type | table           | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
        +----+-------------+-----------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
        |  1 | SIMPLE      | product_comment | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 996663 |   100.00 | Using where |
        +----+-------------+-----------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
    



*   __2、如果对索引使用函数，也会造成失效__

    使用了 `函数` 修饰过的列就不是单独的列啦，这样就无法使用索引进行排序啦
        
        EXPLAIN SELECT comment_id, user_id, comment_text FROM product_comment WHERE SUBSTRING(comment_text, 1,3)='abc'
    
    运行结果：


        +----+-------------+-----------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
        | id | select_type | table           | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
        +----+-------------+-----------------+------------+------+---------------+------+---------+------+--------+----------+-------------+
        |  1 | SIMPLE      | product_comment | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 996663 |   100.00 | Using where |
        +----+-------------+-----------------+------------+------+---------------+------+---------+------+--------+----------+-------------+


    对索引字段进行函数操作，造成了索引失效，这时可以进行查询重写

    
        SELECT comment_id, user_id, comment_text FROM product_comment WHERE comment_text LIKE 'abc%'
    
    运行结果：
    
        +----+-------------+-----------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+
        | id | select_type | table           | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                 |
        +----+-------------+-----------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+
        |  1 | SIMPLE      | product_comment | NULL       | range | comment_text  | comment_text | 767     | NULL |  213 |   100.00 | Using index condition |
        +----+-------------+-----------------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------+


    ** __`注意观察：type 的变化。`__ **


*   __3、在 WHERE 子句中，如果在 OR 前的条件列进行了索引，而在 OR 后的条件列没有进行索引，那么索引会失效。__ 如：

        EXPLAIN SELECT comment_id, user_id, comment_text FROM product_comment WHERE comment_id = 900001 OR comment_text = '462eed7ac6e791292a79'

*   __4、当我们使用 LIKE 进行模糊查询的时候,匹配的字段前不能加 %__，如：

        
        EXPLAIN SELECT comment_id, user_id, comment_text FROM product_comment WHERE comment_text LIKE '%abc'


*   __5、索引列尽量设置为 NOT NULL 约束。__
    
    [官方建议这样做，这样做的好处是可以更好地使用索引，节省空间，甚至加速 SQL 的运行。](https://dev.mysql.com/doc/refman/5.5/en/data-size.html)
    
    `判断索引列是否为 NOT NULL，往往需要走全表扫描`， 因此我们最好在设计数据表的时候就将字段设置为 NOT NULL 约束,比如你可以将 INT 类型的字段，默认值设置为 0。将字符类型的默认值设置为空字符串 ('')。

*   __6、我们在使用联合索引的时候要注意最左原则。__

    举个例子：当我们创建了一个联合索引 `idx_name_birthday_phone_number`
        

        CREATE TABLE person_info(
                id INT NOT NULL auto_increment,
                name VARCHAR(100) NOT NULL,
                birthday DATE NOT NULL,
                phone_number CHAR(11) NOT NULL,
                country varchar(100) NOT NULL,
                PRIMARY KEY (id),
                KEY idx_name_birthday_phone_number (name, birthday, phone_number)
        );

    
    `1️⃣` 接下来使用下列语句对表进行查询：(`能正确使用索引`)
        
        SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
    
    `2️⃣` 接下来使用下列语句对表进行查询：(`能正确使用索引`，顺序不影响索引，MySQL的查询优化器会自动调整顺序)
       
        SELECT * FROM person_info WHERE  birthday = '1990-09-27'  AND name = 'Ashburn' AND phone_number = '15123983239';

    `3️⃣` 接下来再使用下列语句对表进行查询：(`无法使用索引`)

        SELECT * FROM person_info WHERE birthday = '1990-09-27' AND phone_number = '15123983239';

    `4️⃣` 接下来再使用下列语句对表进行查询：(`无法使完整索引`，只能使用 name 的索引)

        SELECT * FROM person_info WHERE name = 'Ashburn'  AND phone_number = '15123983239';

    `注意`: 
    
    我们建立联合索引时，我们的联合索引是二级索引，所以它会额外建立一个联合索引的B+树，而这个B+树如何进行查询呢？
    
    *   因为我们创建的联合索引最左侧的列为 name ，我们是先按照 name 进行排序,然后再在按照 birthday 进行排序，最后按照 phone_number 进行排序，所以 `1️⃣` 能正常的使用联合索引。
    
    *   但是 `3️⃣` 的最左侧是 birthday，所以现在你跳过name列直接根据birthday的值去查找，是做不到的。



*   __7、在使用 GROUP BY 进行排序时：__


    `1️⃣` 接下来再使用下列语句对表进行查询：(`无法使用索引`，ORDER BY中的顺序要和`联合索引`的顺序一致)

        SELECT * FROM person_info WHERE name = 'A' ORDER BY phone_number, birthday, name;

    `2️⃣` 接下来再使用下列语句对表进行查询：(`无法使用完整索引`)

        SELECT * FROM person_info WHERE name = 'A' ORDER BY name, birthday;

    `3️⃣` 接下来再使用下列语句对表进行查询：(`能正确使用索引`)

        SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;
    
        注：这个查询能使用联合索引进行排序是因为name列的值相同的记录是按照birthday, phone_number排序的


*   __8、`ASC`、`DESC` 混用__

    `ASC`、`DESC`不能混用，意思就是不能对联合索引中的 name 进行 `ASC排序(升序)` 对 birthday 进行 `DESC排序(降序)`,如：

        SELECT * FROM person_info ORDER BY name, birthday DESC LIMIT 10;

    要么都是个列都是`ASC规则`排序，要么都是`DESC规则`排序，如：

        ORDER BY name, birthday LIMIT 10

        ORDER BY name DESC, birthday DESC LIMIT 10

*   __9、WHERE子句中出现非排序使用到的索引列__


    如果WHERE子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的，如：

        SELECT * FROM person_info WHERE country = 'China' ORDER BY name LIMIT 10;

    `因为` 这个查询只能先把符合搜索条件 `country = 'China'` 的记录提取出来后再进行排序，是使用不到索引，但是下面的查询语句可以使用索引。

        SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;

    `因为` 我们先找到 name = 'A' 的记录，而 name 位于 idx_name_birthday_phone_number 联合索引的最左侧，而且过滤剩下的记录还是按照birthday、phone_number列排序的，所以还是可以使用索引进行排序的。 


*   __9、排序列包含非同一个索引的列__

    有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，如：

        SELECT * FROM person_info ORDER BY name, country LIMIT 10;

## 扩展：

*   __查找 "不经常使用的" 索引:__
    
    可以查看下MySQL中的performance_schema.table_io_waits_summary_by_index_usage数据表，它表明了每个索引进行统计的I/O等待事件，其中COUNT_STAR代表了事件的次数。过滤掉一些系统表，查看下数据表中有哪些索引不经常使用。
    
    具体的SQL语句：
        
        SELECT OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME,COUNT_STAR FROM 
        performance_schema.table_io_waits_summary_by_index_usage WHERE INDEX_NAME IS NOT NULL
        AND COUNT_STAR = 0
        AND OBJECT_SCHEMA != 'mysql' AND OBJECT_SCHEMA != 'performance_schema'


