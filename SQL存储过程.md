## SQL 存储过程

SQL 的存储过程和视图一样，都是对 SQL 代码进行封装，可以反复利用。它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是虚拟表，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以直接操作底层数据表，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。存储过程可以说是由 SQL 语句和流控制语句构成的语句集合，它和我们之前学到的函数一样，可以接收输入参数，也可以返回输出参数给调用者，返回计算结果。


### 创建存储过程

#### 定义存储过程的语法：

    CREATE PROCEDURE 存储过程名称 ([参数列表])

    BEGIN
        需要执行的语句

    END


#### 存储过程的三种参数类型

    参数类型        是否返回             作用

    IN              否                  向存储过程传递参数，存储过程中修改参数的值，不能被返回
    OUT             是                  把存储过程计算结果放到参数中，调用者可以得到返回值
    INOUT           是                  IN 和 OUT 的结合，既用于存储过程的传递参数，同时又可以把结果放到参数中，调用者可以得到返回值



#### 接下来我们通过例子了解如何创建存储过程和定义参数



#### IN 参数 例子

使用存储过程进行一个累加运算

    CREATE PROCEDURE `add_num`(IN n INT)
    BEGIN
        DECLARE i INT;
        DECLARE sum INT;
        
        SET i = 1;
        SET sum = 0;
        WHILE i <= n DO
                SET sum = sum + i;
                SET i = i +1;
        END WHILE;
        SELECT sum;
    END


这里我们创建了一个名为 add_num 的存储过程，参数列表中 (IN n INT) 定义的是定义一个n参数，同时使用了IN参数标志之后我们会传入参数(就是n的值)，DECLARE为声明变量

之后现在我们就已经创建好了该存储过程了，之后我们使用 __CALL add_num(50);__ 就调用了 add_num 这个存储过程了，也就是我们1+2+3...+50的累加结果

### 在创建存储过程时值得注意的是： 

在mysql中如果我们如果使用上面的命令进行创建存储过程是会报错了，因为在mysql中默认的结束符为 ; 所以一看到 ; 符号，就以为我们这个sql语句写完了，所以我们这里需要先修改一下结束符，等我们语句写完了我们再修改过来即可。但是在Navicat中，我们不需要显式的指定结束符，因为它会自动帮助我们解决。


#### 如下例子

    1、DELIMITER //

    2、 CREATE PROCEDURE `add_num`(IN n INT)
        BEGIN
            DECLARE i INT;
            DECLARE sum INT;
            
            SET i = 1;
            SET sum = 0;
            WHILE i <= n DO
                    SET sum = sum + i;
                    SET i = i +1;
            END WHILE;
            SELECT sum;
        END //

    3、DELIMITER ; 



上面我们举了一个 IN 参数的例子，接下来我们看看 OUT 参数的例子

#### OUT 参数 例子

    1、DELIMITER //

    2、CREATE PROCEDURE `get_player_id` (OUT test INT;OUT max_play_id INT) BEGIN SELECT MAX(player_id) FROM player INTO play_id; END//

    3、DELIMITER ; 

这里我们创建了一个存储过程，过程中定义了 max_play_id 这个参数的值，从我们的 player 这张表中取 player_id 最大的值然后 INTO 赋给 play_id 这个变量。

之后我们如果想要查看这个存储过程的值，我们可以通过以下方法：
    
    CALL test(@test,@play_id)；

    SELECT @test,@play_id;

但是因为我们之前没有赋予 test 值，所以这里我们 SELECT 出来 test 这个列的数据是 null 的

    +--------+----------+
    | @test | @play_id |
    +--------+----------+
    |   NULL |    10037 |
    +--------+----------+


### 修改存储过程

    ALTER PROCEDURE 存储过程名称 ([参数列表])

    BEGIN
        需要执行的语句

    END

### 删除存储过程


    DROP PROCEDURE 存储过程名称



###  流程控制语句

流控制语句是用来做流程控制的，在上面的两个例子中我们用到了下面的流控制语句：

    1、BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。

    2、DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进行变量的声明。

    3、SET：赋值语句，用于对变量进行赋值。

    4、SELECT…INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。

除了上面我们用到的流程控制语句，还有如下等等的流程控制语句：

    1.IF…THEN…ENDIF：条件判断语句，我们还可以在 IF…THEN…ENDIF 中使用 ELSE 和 ELSEIF 来进行条件判断。

    2.CASE：CASE 语句用于多条件的分支判断，使用的语法是下面这样的。

        CASE 
            WHEN expression1 THEN ...
            WHEN expression2 THEN ...
            ...
            ELSE 
            --ELSE 语句可以加，也可以不加。加的话代表的所有条件都不满足时采用的方式。
        END

    3.LOOP、LEAVE 和 ITERATE：LOOP 是循环语句，使用 LEAVE 可以跳出循环，使用 ITERATE 则可以进入下一次循环。
      如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 BREAK，把 ITERATE 理解为 CONTINUE。

    4.REPEAT…UNTIL…END REPEAT：这是一个循环语句，首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；
      如果条件不满足，则会就继续执行循环，直到满足退出条件为止。

    5.WHILE…DO…END WHILE：这也是循环语句，和 REPEAT 循环不同的是，这个语句需要先进行条件判断，如果满足条件就进行循环，如果不满足条件就退出循环。



### 总结

#### 优点

1、首先存储过程可以 __一次编译多次使用__。存储过程只在创造时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。其次它可以减少开发工作量。

2、将代码封装成模块，实际上是编程的核心思想之一，这样可以 __把复杂的问题拆解成不同的模块__ ，然后模块之间可以重复使用，在减少开发工作量的同时，还能保证代码的结构清晰。

3、还有一点，__存储过程的安全性强__ ，我们在设定存储过程的时候 __可以设置对用户的使用权限__，这样就和视图一样具有较强的安全性。

4、最后它 __可以减少网络传输量__，因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。同时在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可。


#### 缺点

1、它的 __可移植性差__ ，存储过程 __不能跨数据库移植__ ，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。

2、其次 __调试困难__，只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。


