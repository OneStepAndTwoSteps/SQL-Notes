# Explain详解


我们可以使用 `EXPLAIN` 语句帮助我们查看某个查询语句的具体执行计划，从而进行查询优化。

首先展示一个 `EXOLAIN` 的展示结果：

    MariaDB [sql_notes]> EXPLAIN SELECT * FROM t1;
    +------+-------------+-------+------+---------------+------+---------+------+------+-------+
    | id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
    +------+-------------+-------+------+---------------+------+---------+------+------+-------+
    |    1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    3 |       |
    +------+-------------+-------+------+---------------+------+---------+------+------+-------+


其中个列分别表示的含义：


| 列名              | 含义 |
| --------------   | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| id             | 执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置 |
| select_type    | SELECT关键字对应的那个查询的类型|
| table          | 访问引用哪个表（引用某个查询，如“derived3”）                                                                                               |
| type           | 针对单表的访问方法（ALL、index、range、ref、eq_ref、const/system、NULL）                                                                   |
| possible_keys  | 可能用到的索引                                                                                                             |
| key            | 实际上使用的索引                                                                                                              |
| key_len        | 实际使用到的索引长度                                                                                                                      |
| ref            | 当使用索引列 `等值查询` 时，与索引列进行等值匹配的对象信息                                                                                  |
| rows           | 为了找到所需的行而需要读取的行数，估算值，不精确。 |
| Extra          | 额外信息，如using index、filesort等          
| 当出现如下列    |                          |  
| partitions           | 匹配的分区信息，基本上都为NULL |
| filtered         | 某个表经过搜索条件过滤后剩余记录条数的百分比，百分比 * rows 就为过滤出来的行数了     |  


## `table` 字段

`EXPLAIN`语句输出的每条记录都对应着某个单表的访问方法，该条记录的 `table` 列代表着该表的表名,如下连接查询：



    MariaDB [sql_notes]> EXPLAIN SELECT * FROM t1 JOIN t2;
    +------+-------------+-------+------+---------------+------+---------+------+------+------------------------------------+
    | id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                              |
    +------+-------------+-------+------+---------------+------+---------+------+------+------------------------------------+
    |    1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    3 |                                    |
    |    1 | SIMPLE      | t2    | ALL  | NULL          | NULL | NULL    | NULL |    3 | Using join buffer (flat, BNL join) |
    +------+-------------+-------+------+---------------+------+---------+------+------+------------------------------------+

不论查询结构如何复杂，到最后也是需要对每个表进行单表访问的。


## `id` 字段 

出现单个  `SELECT` ：

*   出现单个 `SELECT`，只有一个 `id` ：

        MariaDB [sql_notes]> EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.m1=t2.m2 WHERE n2 = 'c';
        +------+-------------+-------+------+---------------+------+---------+------+------+-------------------------------------------------+
        | id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                                           |
        +------+-------------+-------+------+---------------+------+---------+------+------+-------------------------------------------------+
        |    1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    3 |                                                 |
        |    1 | SIMPLE      | t2    | ALL  | NULL          | NULL | NULL    | NULL |    3 | Using where; Using join buffer (flat, BNL join) |
        +------+-------------+-------+------+---------------+------+---------+------+------+-------------------------------------------------+

    这里我们使用了 连接查询 我们发现: 
    
    *   `接在 from 后面如果存在多个表，那么每个表都会对应一条记录，但是这些记录的id值都是 相同 的`。

    *   __`特别注意`__ ：__`出现在前边的表表示驱动表，出现在后边的表表示被驱动表`__

    *   从上面执行结果可以看出：`t1` 为 `驱动表` ,`t2` 为 `被驱动表`。

*   出现多个  `SELECT` ：

    查询语句中每出现一个 `SELECT` 关键字，`MySQL` 就会为它分配一个唯一的 `id` 值

    1、查询中包含子查询的情况：

    *   对于出现多个 `SELECT` 关键字的查询语句，`一般来说`：每个 `SELECT` 关键字都会对应一个`唯一` 的 `id` 值。

    *   `为什么说一般呢`，因为：`查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。`



    2、查询中包含UNION语句的情况：

    *   包含 UNION 的语句一般也都会有独立的关键字，但是特别的使用 UNION 会出现一个特别的 id：

            MariaDB [sql_notes]> EXPLAIN SELECT * FROM s1  UNION SELECT * FROM s2;
            +------+--------------+------------+------+---------------+------+---------+------+------+-------+
            | id   | select_type  | table      | type | possible_keys | key  | key_len | ref  | rows | Extra |
            +------+--------------+------------+------+---------------+------+---------+------+------+-------+
            |    1 | PRIMARY      | s1         | ALL  | NULL          | NULL | NULL    | NULL |    1 |       |
            |    2 | UNION        | s2         | ALL  | NULL          | NULL | NULL    | NULL |    1 |       |
            | NULL | UNION RESULT | <union1,2> | ALL  | NULL          | NULL | NULL    | NULL | NULL |       |
            +------+--------------+------------+------+---------------+------+---------+------+------+-------+

        可以发现其中 第三行的 `id` 为 `NULL`，这是因为 `UNION` 它会建立一个内部的 `临时表`，把多个查询的结果集合并起来，并对结果集中的记录进行去重，我们可以看到，这个内部临时表的名字叫做 `<union1,2>`,`id` 为 `NULL` 表明这个临时表是为了合并两个查询的结果集而创建的。

        这里额外介绍一下 `UNION ALL` ，用它进行合并时，不会对最终的结果去重，只是将多个查询的结果集的记录合并返回，不需要创建 `临时表`,所以不会有 id  为 NULL 的记录，如：

            MariaDB [sql_notes]> EXPLAIN SELECT * FROM s1  UNION ALL SELECT * FROM s2;
            +------+-------------+-------+------+---------------+------+---------+------+------+-------+
            | id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
            +------+-------------+-------+------+---------------+------+---------+------+------+-------+
            |    1 | PRIMARY     | s1    | ALL  | NULL          | NULL | NULL    | NULL |    1 |       |
            |    2 | UNION       | s2    | ALL  | NULL          | NULL | NULL    | NULL |    1 |       |
            +------+-------------+-------+------+---------------+------+---------+------+------+-------+


## `select_type` 字段

表示查询的类型

| 类型                                                               | 说明                                                                                                      |
| -------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| simple          | 简单子查询，不包含子查询和 union                                              |
| primary         | 包含 union 或者子查询，最外层的部分标记为primary                               |
| subquery        | 一般子查询中的子查询被标记为 subquery，也就是位于 select 列表中的查询           |
| derived         | 采用物化的方式执行的包含派生表的查询                     |
| union           | 位于 union 中第二个及其以后的子查询被标记为 union，第一个就被标记为 primary 如果是union 位于 from 中则标记为 derived |
| union result     | 用来从匿名临时表里检索结果的select被标记为union result                        |
| dependent union  | 顾名思义，首先需要满足UNION的条件，及UNION中第二个以及后面的SELECT语句，同时该语句依赖外部的查询 |
| subquery         | 子查询中第一个SELECT语句                                                    |
| dependent subquery  | 和DEPENDENT UNION相对UNION一样                                          |
| MATERIALIZED | 将子查询物化之后与外层查询进行连接查询时|
### simple

简单查询，不包含 `子查询`和 `union` ,其中连接查询也是 `simple`

    MariaDB [sql_notes]> EXPLAIN SELECT * FROM t1 INNER JOIN t2;
    +------+-------------+-------+------+---------------+------+---------+------+------+------------------------------------+
    | id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                              |
    +------+-------------+-------+------+---------------+------+---------+------+------+------------------------------------+
    |    1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    3 |                                    |
    |    1 | SIMPLE      | t2    | ALL  | NULL          | NULL | NULL    | NULL |    3 | Using join buffer (flat, BNL join) |
    +------+-------------+-------+------+---------------+------+---------+------+------+------------------------------------+


### primary

包含 `union` 或者子查询，最`外`层的部分标记为 `primary` , 最外层的的小查询 `SELECT * FROM s1` 对应的是执行计划中的第一条记录，它的 `select_type` 值就是 `PRIMARY`。



    MariaDB [sql_notes]> EXPLAIN SELECT * FROM t1 UNION SELECT * FROM t2;
    +------+--------------+------------+------+---------------+------+---------+------+------+-------+
    | id   | select_type  | table      | type | possible_keys | key  | key_len | ref  | rows | Extra |
    +------+--------------+------------+------+---------------+------+---------+------+------+-------+
    |    1 | PRIMARY      | t1         | ALL  | NULL          | NULL | NULL    | NULL |    3 |       |
    |    2 | UNION        | t2         | ALL  | NULL          | NULL | NULL    | NULL |    3 |       |
    | NULL | UNION RESULT | <union1,2> | ALL  | NULL          | NULL | NULL    | NULL | NULL |       |
    +------+--------------+------------+------+---------------+------+---------+------+------+-------+

### UNION

对于包含 `UNION` 或者 `UNION ALL` 的大查询来说，它是由几个小查询组成的，其中除了最外边的那个小查询以外，其余的小查询的 `select_type` 值就是 `UNION`。

### UNION RESULT

针对 `UNION` 使用 `临时表` 的查询的 `select_type` 就是 `UNION RESULT`,如上例子。

### SUBQUERY

包含子查询的查询语句是 `不相关子查询`，并且不能转化成 `semi-join` 形式，并且优化器采用讲该子查询物化的方式进行查询，那么子查询中第一个SELECT语句， `select_type` 就是 `SUBQUERY`，如下所示：

    MariaDB [sql_notes]> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
    +------+--------------------+-------+----------------+---------------+----------+---------+------+------+-------------+
    | id   | select_type        | table | type           | possible_keys | key      | key_len | ref  | rows | Extra       |
    +------+--------------------+-------+----------------+---------------+----------+---------+------+------+-------------+
    |    1 | PRIMARY            | s1    | ALL            | idx_key3      | NULL     | NULL    | NULL |    1 | Using where |
    |    2 | SUBQUERY | s2    | index_subquery | idx_key1      | idx_key1 | 303     | func |    1 | Using index |
    +------+--------------------+-------+----------------+---------------+----------+---------+------+------+-------------+

注意：`select_type为SUBQUERY的子查询会被物化，所以只需要执行一遍。`

### DEPENDENT  SUBQUERY

包含子查询的查询语句是 `相关子查询` ，并且不能转化成 `semi-join` 形式, 则该子查询的第一个 `SELECT` 关键字代表的那个查询的`select_type` 就是 `DEPENDENT SUBQUERY`:


    MariaDB [sql_notes]> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a';
    +------+--------------------+-------+------+-------------------+----------+---------+-------------------------+------+-------------+
    | id   | select_type        | table | type | possible_keys     | key      | key_len | ref                     | rows | Extra       |
    +------+--------------------+-------+------+-------------------+----------+---------+-------------------------+------+-------------+
    |    1 | PRIMARY            | s1    | ALL  | idx_key3          | NULL     | NULL    | NULL                    |    1 | Using where |
    |    2 | DEPENDENT SUBQUERY | s2    | ref  | idx_key2,idx_key1 | idx_key2 | 5       | sql_notes.s1.key2 |    1 | Using where |
    +------+--------------------+-------+------+-------------------+----------+---------+-------------------------+------+-------------+


注意：`select_type为DEPENDENT SUBQUERY的查询可能会被执行多次.`

### DERIVED

采用物化的方式执行的包含 `派生表` (`由子查询结果集组成的表称之为派生表`) 的查询,如下：

    MariaDB [sql_notes]> EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c > 1;
    +------+-------------+------------+-------+---------------+----------+---------+------+------+-------------+
    | id   | select_type | table      | type  | possible_keys | key      | key_len | ref  | rows | Extra       |
    +------+-------------+------------+-------+---------------+----------+---------+------+------+-------------+
    |    1 | PRIMARY     | <derived2> | ALL   | NULL          | NULL     | NULL    | NULL |    2 | Using where |
    |    2 | DERIVED     | s1         | index | NULL          | idx_key1 | 303     | NULL |    1 | Using index |
    +------+-------------+------------+-------+---------------+----------+---------+------+------+-------------+


可以看出 `id` 为 `2` 的 `SELECT key1, count(*) as c FROM s1 GROUP BY key1` 子查询记录，采用的是 `物化` 的方式执行的，同时我们可以看出 `id` 为 `1` ，的记录它的  `table` 为 `<derived2>`，也就是该查询是针对将派生表物化之后的表进行查询的。





## `type` 字段

`type` 字段用于描述查询使用的是什么访问方法

`InnoDB` 存储引擎的表进行单表访问的一些访问方法，完整的访问方法如下：`system`，`const`，`eq_ref`，`ref`，`fulltext`，`ref_or_null`，`index_merge`，`unique_subquery`，`index_subquery`，`range`，`index`，`ALL`



| 类型                                                               | 说明                                                                                                      |
| -------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| system          | 当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如 `MyISAM` 、`Memory` ，那么对该表的访问方法就是 `system`                                            |
| const         | 主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是 `const`                         |
| eq_ref        | 连接查询 + 被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问,如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较则对该被驱动表的访问方法就是 `eq_ref`         |
| ref         | 普通的二级索引列与常量进行等值匹配时来查询某个表访问方法就 `可能` 是 `ref `                    |
| fulltext           | 全文索引 |
| ref_or_null    | 对普通二级索引进行等值匹配查询，该索引列的值也可以是 `NULL` 值时，那么对该表的访问方法就 `可能` 是 `ref_or_null`                   |
| index_merge   | 使用Intersection、Union、Sort-Union这三种索引合并的方式来执行查询时为 `index_merge`  |
| unique_subquery         | 查询优化器决定将 `IN` 子查询转换为 `EXISTS` 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 `type` 列的值就是 `unique_subquery`   |
| index_subquery  | 与 `unique_subquery` 类似，只不过访问子查询中的表时使用的是普通的索引                         |
| range | 使用索引获取某些范围区间的记录，那么就可能使用到 `range` 访问方法|
| index | 使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 `index`,比如我们想要使用一个字段索引，但是这个字段在联合索引中，如果不得不使用联合索引了，那么需要扫描联合索引的全部记录 |
| ALL | 全表扫描 |




## `possible_keys 和 key` 字段

`possible_keys` 可能用到的索引， `key` 用到的索引

需要注意的是，在使用index访问方法来查询某个表时 `possible_keys` 为 `NULL` ，但是 `key` 却不为空。

并且 `possible_keys` 列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引

如下：

    MariaDB [sql_notes]>  EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
    +------+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+
    | id   | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra                    |
    +------+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+
    |    1 | SIMPLE      | s1    | index | NULL          | idx_key_part | 909     | NULL |    1 | Using where; Using index |
    +------+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+


可以看到 `possible_keys` 为 `NULL`，因为根据我们的查询语句，`key_part2` 和 `key_part3` 不是索引，这里使用的是 联合索引 `idx_key_part`


## `key_len` 字段

key_len 用于表示索引记录的最大长度。

*   索引的最大长度 = 字符集所占字节数 * 索引类型指定的大小，如：当字符集取 utf8 ，数据类型为 varchar(100) 就等于： 3 * 100 = 300

*   如果该索引列可以存储NULL值，则key_len比不可以存储NULL值时多1个字节。

*   对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。

这个 `key_len` 值主要就是表示查询中使用到了几个索引列，如：


    MariaDB [sql_notes]>  EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
    +------+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+
    | id   | select_type | table | type  | possible_keys | key          | key_len | ref  | rows | Extra                    |
    +------+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+
    |    1 | SIMPLE      | s1    | index | NULL          | idx_key_part | 909     | NULL |    1 | Using where; Using index |
    +------+-------------+-------+-------+---------------+--------------+---------+------+------+--------------------------+

此时我们可以看出 `key_len` 为909，同时 idx 索引中的三个字段 都为 varchar(100)，所以可以看出，我们使用到了索引列 中的三个索引。



## `ref` 字段


ref列展示的就是与索引列作等值匹配时的方法是什么，如下：

    MariaDB [sql_notes]>  EXPLAIN SELECT * FROM s1 WHERE key1 = 'a';
    +------+-------------+-------+------+---------------+----------+---------+-------+------+-----------------------+
    | id   | select_type | table | type | possible_keys | key      | key_len | ref   | rows | Extra                 |
    +------+-------------+-------+------+---------------+----------+---------+-------+------+-----------------------+
    |    1 | SIMPLE      | s1    | ref  | idx_key1      | idx_key1 | 303     | const |    1 | Using index condition |
    +------+-------------+-------+------+---------------+----------+---------+-------+------+-----------------------+

可以看出 `ref` 为 `const` 表示等值匹配。

    MariaDB [sql_notes]> EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;
    +------+-------------+-------+--------+---------------+---------+---------+-----------------------+------+-------+
    | id   | select_type | table | type   | possible_keys | key     | key_len | ref                   | rows | Extra |
    +------+-------------+-------+--------+---------------+---------+---------+-----------------------+------+-------+
    |    1 | SIMPLE      | s1    | ALL    | PRIMARY       | NULL    | NULL    | NULL                  |    1 |       |
    |    1 | SIMPLE      | s2    | eq_ref | PRIMARY       | PRIMARY | 4       | sql_notes.s1.id |    1 |       |
    +------+-------------+-------+--------+---------------+---------+---------+-----------------------+------+-------+


此时 `ref` 为 `sql_notes.s1.id` 也就是与 `s2` 表作匹配的对象是 `sql_notes.s1.id` 列


## `rows` 字段

row 字段表示预计需要扫描的行数 (估计值)



