# Explain详解


我们可以使用 `EXPLAIN` 语句帮助我们查看某个查询语句的具体执行计划，从而进行查询优化。

首先展示一个 `EXOLAIN` 的展示结果：

    MariaDB [sql_notes]> EXPLAIN SELECT * FROM t1;
    +------+-------------+-------+------+---------------+------+---------+------+------+-------+
    | id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
    +------+-------------+-------+------+---------------+------+---------+------+------+-------+
    |    1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    3 |       |
    +------+-------------+-------+------+---------------+------+---------+------+------+-------+


其中个列分别表示的含义：


| 列名              | 含义 |
| --------------   | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| id             | 执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置 |
| select_type    | SELECT关键字对应的那个查询的类型|
| table          | 访问引用哪个表（引用某个查询，如“derived3”）                                                                                               |
| type           | 针对单表的访问方法（ALL、index、range、ref、eq_ref、const/system、NULL）                                                                   |
| possible_keys  | 可能用到的索引                                                                                                             |
| key            | 实际上使用的索引                                                                                                              |
| key_len        | 实际使用到的索引长度                                                                                                                      |
| ref            | 当使用索引列 `等值查询` 时，与索引列进行等值匹配的对象信息                                                                                  |
| rows           | 为了找到所需的行而需要读取的行数，估算值，不精确。 |
| Extra          | 额外信息，如using index、filesort等          
| 当出现如下列    |                          |  
| partitions           | 匹配的分区信息，基本上都为NULL |
| filtered         | 某个表经过搜索条件过滤后剩余记录条数的百分比，百分比 * rows 就为过滤出来的行数了     |  


## `table` 字段

`EXPLAIN`语句输出的每条记录都对应着某个单表的访问方法，该条记录的 `table` 列代表着该表的表名,如下连接查询：



    MariaDB [sql_notes]> EXPLAIN SELECT * FROM t1 JOIN t2;
    +------+-------------+-------+------+---------------+------+---------+------+------+------------------------------------+
    | id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                              |
    +------+-------------+-------+------+---------------+------+---------+------+------+------------------------------------+
    |    1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    3 |                                    |
    |    1 | SIMPLE      | t2    | ALL  | NULL          | NULL | NULL    | NULL |    3 | Using join buffer (flat, BNL join) |
    +------+-------------+-------+------+---------------+------+---------+------+------+------------------------------------+

不论查询结构如何复杂，到最后也是需要对每个表进行单表访问的。


## `id` 字段 

出现单个  `SELECT` ：

*   出现单个 `SELECT`，只有一个 `id` ：

        MariaDB [sql_notes]> EXPLAIN SELECT * FROM t1 JOIN t2 ON t1.m1=t2.m2 WHERE n2 = 'c';
        +------+-------------+-------+------+---------------+------+---------+------+------+-------------------------------------------------+
        | id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                                           |
        +------+-------------+-------+------+---------------+------+---------+------+------+-------------------------------------------------+
        |    1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    3 |                                                 |
        |    1 | SIMPLE      | t2    | ALL  | NULL          | NULL | NULL    | NULL |    3 | Using where; Using join buffer (flat, BNL join) |
        +------+-------------+-------+------+---------------+------+---------+------+------+-------------------------------------------------+

    这里我们使用了 连接查询 我们发现: 
    
    *   `接在 from 后面如果存在多个表，那么每个表都会对应一条记录，但是这些记录的id值都是 相同 的`。

    *   __`特别注意`__ ：__`出现在前边的表表示驱动表，出现在后边的表表示被驱动表`__

    *   从上面执行结果可以看出：`t1` 为 `驱动表` ,`t2` 为 `被驱动表`。

*   出现多个  `SELECT` ：

    查询语句中每出现一个 `SELECT` 关键字，`MySQL` 就会为它分配一个唯一的 `id` 值

    1、查询中包含子查询的情况：

    *   对于出现多个 `SELECT` 关键字的查询语句，`一般来说`：每个 `SELECT` 关键字都会对应一个`唯一` 的 `id` 值。

    *   `为什么说一般呢`，因为：`查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。`



    2、查询中包含UNION语句的情况：

    *   包含 UNION 的语句一般也都会有独立的关键字，但是特别的使用 UNION 会出现一个特别的 id：

            MariaDB [sql_notes]> EXPLAIN SELECT * FROM s1  UNION SELECT * FROM s2;
            +------+--------------+------------+------+---------------+------+---------+------+------+-------+
            | id   | select_type  | table      | type | possible_keys | key  | key_len | ref  | rows | Extra |
            +------+--------------+------------+------+---------------+------+---------+------+------+-------+
            |    1 | PRIMARY      | s1         | ALL  | NULL          | NULL | NULL    | NULL |    1 |       |
            |    2 | UNION        | s2         | ALL  | NULL          | NULL | NULL    | NULL |    1 |       |
            | NULL | UNION RESULT | <union1,2> | ALL  | NULL          | NULL | NULL    | NULL | NULL |       |
            +------+--------------+------------+------+---------------+------+---------+------+------+-------+

        可以发现其中 第三行的 `id` 为 `NULL`，这是因为 `UNION` 它会建立一个内部的 `临时表`，把多个查询的结果集合并起来，并对结果集中的记录进行去重，我们可以看到，这个内部临时表的名字叫做 `<union1,2>`,`id` 为 `NULL` 表明这个临时表是为了合并两个查询的结果集而创建的。

        这里额外介绍一下 `UNION ALL` ，用它进行合并时，不会对最终的结果去重，只是将多个查询的结果集的记录合并返回，不需要创建 `临时表`,所以不会有 id  为 NULL 的记录，如：

            MariaDB [sql_notes]> EXPLAIN SELECT * FROM s1  UNION ALL SELECT * FROM s2;
            +------+-------------+-------+------+---------------+------+---------+------+------+-------+
            | id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
            +------+-------------+-------+------+---------------+------+---------+------+------+-------+
            |    1 | PRIMARY     | s1    | ALL  | NULL          | NULL | NULL    | NULL |    1 |       |
            |    2 | UNION       | s2    | ALL  | NULL          | NULL | NULL    | NULL |    1 |       |
            +------+-------------+-------+------+---------------+------+---------+------+------+-------+


## `select_type` 字段

表示查询的类型

| 类型                                                               | 说明                                                                                                      |
| -------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| simple          | 简单子查询，不包含子查询和 union                                              |
| primary         | 包含 union 或者子查询，最外层的部分标记为primary                               |
| subquery        | 一般子查询中的子查询被标记为 subquery，也就是位于 select 列表中的查询           |
| derived         | 派生表——该临时表是从子查询派生出来的，位于 form 中的子查询                     |
| union           | 位于 union 中第二个及其以后的子查询被标记为 union，第一个就被标记为 primary 如果是union 位于 from 中则标记为 derived |
| union result     | 用来从匿名临时表里检索结果的select被标记为union result                        |
| dependent union  | 顾名思义，首先需要满足UNION的条件，及UNION中第二个以及后面的SELECT语句，同时该语句依赖外部的查询 |
| subquery         | 子查询中第一个SELECT语句                                                    |
| dependent subquery  | 和DEPENDENT UNION相对UNION一样                                          |

### simple

简单查询，不包含 `子查询`和 `union` ,其中连接查询也是 `simple`

    MariaDB [sql_notes]> EXPLAIN SELECT * FROM t1 INNER JOIN t2;
    +------+-------------+-------+------+---------------+------+---------+------+------+------------------------------------+
    | id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                              |
    +------+-------------+-------+------+---------------+------+---------+------+------+------------------------------------+
    |    1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL |    3 |                                    |
    |    1 | SIMPLE      | t2    | ALL  | NULL          | NULL | NULL    | NULL |    3 | Using join buffer (flat, BNL join) |
    +------+-------------+-------+------+---------------+------+---------+------+------+------------------------------------+


### primary

包含 `union` 或者子查询，最`外`层的部分标记为 `primary` , 最外层的的小查询 `SELECT * FROM s1` 对应的是执行计划中的第一条记录，它的 `select_type` 值就是 `PRIMARY`。



    MariaDB [sql_notes]> EXPLAIN SELECT * FROM t1 UNION SELECT * FROM t2;
    +------+--------------+------------+------+---------------+------+---------+------+------+-------+
    | id   | select_type  | table      | type | possible_keys | key  | key_len | ref  | rows | Extra |
    +------+--------------+------------+------+---------------+------+---------+------+------+-------+
    |    1 | PRIMARY      | t1         | ALL  | NULL          | NULL | NULL    | NULL |    3 |       |
    |    2 | UNION        | t2         | ALL  | NULL          | NULL | NULL    | NULL |    3 |       |
    | NULL | UNION RESULT | <union1,2> | ALL  | NULL          | NULL | NULL    | NULL | NULL |       |
    +------+--------------+------------+------+---------------+------+---------+------+------+-------+

### UNION

对于包含 `UNION` 或者 `UNION ALL` 的大查询来说，它是由几个小查询组成的，其中除了最外边的那个小查询以外，其余的小查询的 `select_type` 值就是 `UNION`。

### UNION RESULT

针对 `UNION` 使用 `临时表` 的查询的 `select_type` 就是 `UNION RESULT`,如上例子。

### SUBQUERY

包含子查询的查询语句是 `不相关子查询`，并且不能转化成 `semi-join` 形式，并且优化器采用讲该子查询物化的方式进行查询，那么子查询中第一个SELECT语句， `select_type` 就是 `SUBQUERY`，如下所示：

    MariaDB [sql_notes]> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = 'a';
    +------+--------------------+-------+----------------+---------------+----------+---------+------+------+-------------+
    | id   | select_type        | table | type           | possible_keys | key      | key_len | ref  | rows | Extra       |
    +------+--------------------+-------+----------------+---------------+----------+---------+------+------+-------------+
    |    1 | PRIMARY            | s1    | ALL            | idx_key3      | NULL     | NULL    | NULL |    1 | Using where |
    |    2 | SUBQUERY | s2    | index_subquery | idx_key1      | idx_key1 | 303     | func |    1 | Using index |
    +------+--------------------+-------+----------------+---------------+----------+---------+------+------+-------------+

注意：`select_type为SUBQUERY的子查询会被物化，所以只需要执行一遍。`

### DEPENDENT  SUBQUERY

包含子查询的查询语句是 `相关子查询` ，并且不能转化成 `semi-join` 形式, 则该子查询的第一个 `SELECT` 关键字代表的那个查询的`select_type` 就是 `DEPENDENT SUBQUERY`:


    MariaDB [sql_notes]> EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = 'a';
    +------+--------------------+-------+------+-------------------+----------+---------+-------------------------+------+-------------+
    | id   | select_type        | table | type | possible_keys     | key      | key_len | ref                     | rows | Extra       |
    +------+--------------------+-------+------+-------------------+----------+---------+-------------------------+------+-------------+
    |    1 | PRIMARY            | s1    | ALL  | idx_key3          | NULL     | NULL    | NULL                    |    1 | Using where |
    |    2 | DEPENDENT SUBQUERY | s2    | ref  | idx_key2,idx_key1 | idx_key2 | 5       | sql_notes.s1.key2 |    1 | Using where |
    +------+--------------------+-------+------+-------------------+----------+---------+-------------------------+------+-------------+


注意：`select_type为DEPENDENT SUBQUERY的查询可能会被执行多次.`
