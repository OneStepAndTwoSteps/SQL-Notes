# 连接成本

### 创建表

    CREATE TABLE single_table (
        id INT NOT NULL AUTO_INCREMENT,
        key1 VARCHAR(100),
        key2 INT,
        key3 VARCHAR(100),
        key_part1 VARCHAR(100),
        key_part2 VARCHAR(100),
        key_part3 VARCHAR(100),
        common_field VARCHAR(100),
        PRIMARY KEY (id),
        KEY idx_key1 (key1),
        UNIQUE KEY idx_key2 (key2),
        KEY idx_key3 (key3),
        KEY idx_key_part(key_part1, key_part2, key_part3)
    ) Engine=InnoDB CHARSET=utf8;


### 成本 = I/O成本 + CPU成本

一句mysql查询语句有不同的执行方案，查询优化器会选择出成本代价最低的执行方法进行执行，如何衡量代价最低？

*   `I/O成本` 

    将数据从磁盘读取到内存中消耗的时间称为`I/O成本`，（MyIsam和InnoDB的数据和索引都是存储在磁盘上，需要先将数据从磁盘读取到内存中方能处理）。

    读取一个页面花费的成本默认是`1.0`。

*   `CPU成本 `
    
    比如对查询语句进行过滤或者排序所消耗的时间称为`CPU成本`

    读取以及检测一条记录是否符合搜索条件的成本默认是`0.2`。

### 成本判断流程：


对于B+树索引来说，只要索引列和`常数`使用 `=`、`<=>`、`IN`、`NOT IN`、`IS NULL`、`IS NOT NULL`、`>`、`<`、`>=`、`<=`、`BETWEEN`、`!=`（不等于也可以写成`<>`）或者`LIKE`操作符连接起来，就可以产生一个所谓的`区间`。（`LIKE`匹配字符串前缀也行），也就是说这些搜索条件都可能使用到索引，设计`MySQL`的大叔把一个查询中可能使用到的索引称之为`possible keys`。

注意：是和常数之间使用这些符号，比如下面的语句就无法使用索引！

    key3 > key2，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。


*   1、根据搜索条件，找出所有可能使用的索引。

*   2、计算全表扫描的代价。
    
    *   `I/O`: `聚簇索引的页面数量` * `加载一个页面的成本常数(1.0)` + `微调值`

    *   `CPU`：`统计数据中表的记录数(是一个估计值)` *  `访问一条记录所需的成本常数(0.2)` + `微调值`

    *   `总成本` = `I/O成本` + `CPU成本`
    
    *   计算 `聚簇索引的页面数量` 和 `统计数据中表的记录数`：

            SHOW TABLE STATUS LIKE 'table_name'\G

            Rows: 9693                      # 表中的记录条数，在Innodb存储引擎中 该值为估计值。
            Data_length: 1589248            # 表占用的存储空间字节数

            聚簇索引的页面数量 = Data_length / 每个页面的大小 / 1024 


*   3、计算使用不同索引执行查询的代价。

    考虑 `二级索引 + 回表`，唯一二级索引和普通二级索引在定位单点区间记录条数是存在差别。

    *   `I/O成本`：范围区间的数量 + 预估的二级索引记录条数

        `范围区间的数量`：查询优化器粗暴的认为读取索引的一个`范围区间`的`I/O成本`和读取一个`页面`是相同的，比如 `key1 >10 and key1 <1000` 认为访问这个`区间`的`I/O成本`为`1.0`,如果为 `IN ('A','B','C')` 表示为`3个单点区间`，则认为`I/O成本`为`3.0`。


        `预估的二级索引记录条数`：计算`区间最左记录`和`区间最右记录`之间的`页面数量`(就相当于计算页b和页c之间有多少页面)，而每一条目录项记录都对应一个数据页，所以计算页b和页c之间有多少页面就相当于计算它们父节点（也就是页a）中对应的目录项记录之间隔着几条记录(`唯一二级索引`)。

        值得注意的是：`非唯一二级索引`，是无法直接得到 所有单点区间 的总记录条数的，需要得到每一个单点区间的记录数，然后相加，得到的方式也是通过计算`区间最左记录`和`区间最右记录`，然后计算出它们之间的记录数，如：

            IN ('A','B','C') 

            先计算 ['A','A'] 之间的记录数 比如 50

            再计算 ['B','B'] 之间的记录数 比如 60

            先计算 ['C','C'] 之间的记录数 比如 70

            三个单点区间总共需要回表的记录数：50 + 60 + 70 = 180

    *   `CPU成本`: 读取二级索引记录的成本 + 读取并检测回表后聚簇索引记录的成本 

        二级索引记录条数 x 0.2 + 0.01 + 回表后聚簇索引记录 x 0.2 = 38.01

    *   考虑是否需要索引合并 (Intersection索引合并)

        前提：1、搜索条件 使用 AND, 2、二级索引记录按照`主键值`进行`排序`的。

    *   对于单点区间查询来说，当使用 IN 语句就容易产生非常多的单点区间，如果这个索引不是唯一二级索引，那么并不能确定一个单点区间对应的二级索引记录的条数有多少，需要我们去计算(获取索引对应的B+树的区间最左记录和区间最右记录，然后再计算这两条记录之间有多少记录（记录条数少的时候可以做到精确计算，多的时候只能估算）)。

        在MySQL中：计算某个范围区间对应的索引记录条数的方式称之为 `index dive`。

        为了防止过多的单点查询造成计算量的巨大，那么在MySQL的系统变量中存储了一个  `eq_range_index_dive_limit` 用于设定最大的单点区间查询次数，比如现在设定为 200 ，那么 单点区间的个数超过200，我们将不再使用上述的计算方式计算记录条数，而使用索引统计数据来进行估算，因为再那么计算的话性能损耗大。

        索引统计数据来进行估算(不精确)：    

            SHOW INDEX FROM single_table;

            Cardinality                 # 索引列中不重复值的数量。

            一个值的重复次数 ≈ Rows ÷ Cardinality

            共需要回表的记录数 = 一个值的重复次数 * 单点区间的个数

4、对比各种执行方案的代价，找出成本最低的那一个。



### 两表连接的成本公式：

对驱动表进行查询后得到的记录条数称之为驱动表的`扇出`。

    连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本

注意：使用内连接连接两表时驱动表由查询优化器判断选择，使用左连接或者右连接连接两表，驱动表是由自己指定的。

### 内连接查询成本

对于下列查询：

    SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2 
    ON s1.key1 = s2.common_field 
    WHERE s1.key2 > 10 AND s1.key2 < 1000 AND 
          s2.key2 > 1000 AND s2.key2 < 2000;

可以选择的连接顺序有两种：

*   `s1`连接`s2`，也就是`s1`作为`驱动表`，`s2`作为`被驱动表`。

*   `s2`连接`s1`，也就是`s2`作为`驱动表`，`s1`作为`被驱动表`。

查询优化器需要分别考虑使用不同的驱动表时的查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各个表的最优访问方法作为最终的查询计划。

*   使用`s1`作为`驱动表`的情况
    
        1、分析对于驱动表的成本最低的执行方案

            首先看一下涉及s1表单表的搜索条件有哪些

                s1.key2 > 10 AND s1.key2 < 1000

            从全表扫描和使用idx_key1这两个方案中选出成本最低的那个，假设使用idx_key1执行查询的成本更低些。

        2、然后分析对于被驱动表的成本最低的执行方案
            
            此时查看涉及被驱动表s2的搜索条件：

                s2.common_field = 常数 

                s2.key2 > 1000 AND s2.key2 < 2000

        注释：s2.common_field = 常数 是因为对驱动表s1结果集中的每一条记录，都需要进行一次被驱动表s2的访问，
        此时那些涉及两表的条件现在相当于只涉及被驱动表s2了。

        因为 s2.common_field 没有创建索引，所以并没有什么用。
        此时访问s2表时可用的方案也是全表扫描和使用idx_key2两种，假设使用idx_key2的成本更小。

        3、连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本


*   使用`s2`作为`驱动表`的情况

        1、分析对于驱动表的成本最低的执行方案

            首先看一下涉及s1表单表的搜索条件有哪些

                s2.key2 > 1000 AND s2.key2 < 2000

            从全表扫描和使用idx_key2这两个方案中选出成本最低的那个，假设使用idx_key2执行查询的成本更低些。

        2、然后分析对于被驱动表的成本最低的执行方案
            
            此时查看涉及被驱动表s2的搜索条件：

                s1.key1 = 常数

                s1.key2 > 10 AND s1.key2 < 2000

            因为 s1.key1 创建了索引，那么可以进行ref方式的访问。

        这时就很有趣了，使用idx_key1可以进行ref方式的访问，使用idx_key2可以使用range方式的访问。这是优化器需要从全表扫描、使用idx_key1、使用idx_key2这几个方案里选出一个成本最低的方案。
        
        被驱动表分析：值得注意的是，idx_key2的范围区间是确定的：(10, 2000)，怎么计算使用idx_key2的成本我们上边已经说过了，在我们没有真正查询前，s1.key1 = 常数 的常数我们是不知道的，那么怎么衡量使用idx_key1执行查询的成本呢？直接使用索引统计数据就好了（就是索引列平均一个值重复多少次）。一般情况下，ref的访问方式要比range成本更低，这里假设使用idx_key1进行对s1的访问。

        3、连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本


连接查询成本占大头的其实是 `驱动表扇出数` x `单次访问被驱动表` 的成本，所以我们的优化重点其实是下边这两个部分：

*   尽量减少`驱动表`的扇出

*   对`被驱动表`的访问成本尽量低

从内连接中的发现：这一点对于我们实际书写连接查询语句时十分有用，我们需要尽量在`被驱动表`的连接列上建立`索引`，这样就可以使用`ref访问方法`来降低访问`被驱动表`的成本了。如果可以，`被驱动表`的连接列最好是该表的`主键`或者`唯一二级索引列`，这样就可以把访问`被驱动表`的成本降到更低了。

