# 连接查询 join 


## 创建测试表

    MariaDB [sql_notes]> CREATE TABLE t1 (m1 int, n1 char(1));
    Query OK, 0 rows affected (0.01 sec)

    MariaDB [sql_notes]> CREATE TABLE t2 (m2 int, n2 char(1));
    Query OK, 0 rows affected (0.00 sec)

    MariaDB [sql_notes]> INSERT INTO t1 VALUES(1, 'a'), (2, 'b'), (3, 'c');
    Query OK, 3 rows affected (0.00 sec)
    Records: 3  Duplicates: 0  Warnings: 0

    MariaDB [sql_notes]> INSERT INTO t2 VALUES(2, 'b'), (3, 'c'), (4, 'd');
    Query OK, 3 rows affected (0.01 sec)
    Records: 3  Duplicates: 0  Warnings: 0


## 笛卡尔乘积

直接使用：

    select * from t1,t2

返回的结果就是笛卡尔乘积：

    +------+------+------+------+
    | m1   | n1   | m2   | n2   |
    +------+------+------+------+
    |    1 | a    |    2 | b    |
    |    2 | b    |    2 | b    |
    |    3 | c    |    2 | b    |
    
    |    1 | a    |    3 | c    |
    |    2 | b    |    3 | c    |
    |    3 | c    |    3 | c    |
    
    |    1 | a    |    4 | d    |
    |    2 | b    |    4 | d    |
    |    3 | c    |    4 | d    |
    +------+------+------+------+

能发现：
    
*   `t1` 中的每一条数据都与 `t2` 中的每一条数据互相匹配 结果返回 `3*3` 的返回集。  

*   使用 `笛卡尔乘积` 在数据量巨大的情况下返回的数据条目是十分巨大的！比如连接三张`100`条数据的表，那么 `笛卡尔乘积` 就是 `100 * 100 *100 = 1000000` 条数据。

如何避免 `笛卡尔乘积` 呢？使用过滤手法

## 连接过程介绍


我们可以在连接表的时候过滤掉不符合条件的条目，我们可以将查询过滤方法分为两种：

*   单表查询：直接使用 where 过滤

*   多表查询：可以使用 t1.m1 = t2.m2 方法进行过滤

### 驱动表和被驱动表

首先我们需要先理解两个概念，驱动表和被驱动表：

*   1）指定了联接条件时，满足查询条件的记录行数少的表为[驱动表]

*   2）未指定联接条件时，`行数少` 的表为[驱动表]（Important!）

忠告：如果你搞不清楚该让谁做驱动表、谁 join 谁，请让 MySQL 运行时自行判断，不使用左右join。


### 如：当我们使用一下查询语句进行查询：

    SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';

那么这个连接查询的大致执行过程如下：

*   首先确定 `驱动表` (MySQL优化器会自己选择 `代价小的表` 作为 `驱动表` ，如const、ref、ref_or_null、range、index、all这些执行方法中选取代价最小的去执行查询)，假如选择的 `驱动表` 为 `t1`，那么会先过滤出 `t1.m1 > 1` 的记录。

*   接着会到 `t2` 表中寻找符合 `t1.m1 = t2.m2` 和 `t2.n2 < 'd'` 条件的记录，因为是根据t1的记录来匹配t2，所以t2表我们将其称为 `被驱动表` 。

小结：我们可以看出，在查询时 t1 只查询了一次，t2 查询了2次，即 驱动表只访问一次，被驱动表会被多次访问，`具体访问几遍取决于对驱动表执行单表查询后的结果集中的记录条数`。

### 内连接和外连接

内连接：


*   在 `驱动表` 中能找到在 `被驱动表` 中找不到的记录，不会被加入到最后的结果集。

*   查询语句：
      
        SELECT * FROM t1,t2

        SELECT * FROM t1 join t2

        SELECT * FROM t1 inner join t2

外连接：

*   左连接 
        
        SELECT * FROM t1 LEFT JOIN t2 ON 连接条件 [WHERE 过滤条件]

        选取左侧的表为 驱动表 。

*   右连接

        SELECT * FROM t1 RIGHT JOIN t2 ON 连接条件 [WHERE 过滤条件]

        选取右侧的表为 驱动表 。

连接过滤语法：

*   WHERE 

    内外连接 WHERE 的作用是一致的，都是过滤。

*   ON

    在 `驱动表` 中找得到的记录，在 `被驱动表` 中找不到响应匹配的记录，但是使用 `ON` 语句进过滤，那么该记录的记过还会被纳入到结果集中，只是被驱动表中的记录使用 `NULL` 填充，如下面的案例展示。

    需要注意的是，这个 `ON` 子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，我们也一般把放到 `ON` 子句中的过滤条件也称之为 `连接条件` 。
    
    所以如果把 `ON` 子句放到内连接中，`MySQL` 会把它和 `WHERE` 子句一样对待，也就是说：内连接中的 `WHERE` 子句和 `ON`子句是等价的。


案例展示：

    MariaDB [sql_notes]> SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2;
    +------+------+------+------+
    | m1   | n1   | m2   | n2   |
    +------+------+------+------+
    |    2 | b    |    2 | b    |
    |    3 | c    |    3 | c    |
    |    1 | a    | NULL | NULL |
    +------+------+------+------+
    3 rows in set (0.00 sec)


    MariaDB [sql_notes]> SELECT * FROM t1 RIGHT JOIN t2 ON t1.m1 = t2.m2;
    +------+------+------+------+
    | m1   | n1   | m2   | n2   |
    +------+------+------+------+
    |    2 | b    |    2 | b    |
    |    3 | c    |    3 | c    |
    | NULL | NULL |    4 | d    |
    +------+------+------+------+
    3 rows in set (0.00 sec)

## 连接原理

### 嵌套循环连接（Nested-Loop Join）

就像上面连接过程中的查询描述一样，当我们进行查询语句的时候：

*   1、首先找到 `驱动表` 然后访问一次驱动表，满足条件的数据过滤出来。

*   2、再根据 `驱动表` 中的数据，匹配 `非驱动表` 中的数据，如果有多个匹配条件，那么将多次访问 `被驱动表` 将满足条件的数据过滤出来。

*   3、若存在 `三表查询` ，则 `t1` 和 `t2` 表得到的结果集相当于一个 `驱动表`，`t3` 会在 `t2` 得到的基础上再进行多次访问查询，访问的次数也就是 `t2` 过滤出的条目。

*   4、多表以此类推.....

小结：`嵌套循环连接` 是一种简单的查询手法，但是很笨拙。

### 使用索引对嵌套循环连接进行加速查询

当使用 嵌套循环连接 进行查询时，被驱动表是可能被多次访问的，如果每次都是全盘扫描的话，那么将十分消耗资源，此时我们可以使用索引加速

比如：

    SELECT * FROM t2 WHERE t2.m2 = 2 AND t2.n2 < 'd';

*   在该查询语句中，我们可以对等值查询时设置索引，因为此时可能使用的访问方法为 `ref` ，如果索引为主键或者唯一二级索引，那么就是 `const` 访问方法 (在连接查询时被称为eq_ref方法)。

*   在范围查询中设置索引可能使用 `range` 方法。

注意：

*   设置了索引并不一定就会使用索引，关键看 `二级索引 + 回表` 所产生的 `代价` 是否比全盘扫描代价更大。

*   不建议使用 `*` 作为查询条件，建议使用真实列作为查询列表。因为有的时候连接查询的查询列，只包含 `被驱动表` 的部分列，可能都是 `联合索引` 中的一部分，此时就不能使用 类似于 `eq_ref` , `ref` 等访问方法，但是可以使用执行对 `被驱动表` 的查询的话，可以使用`索引扫描`，也就是是 `index` 的访问方法来查询 `被驱动表`。

### 基于块的嵌套循环连接

__简而言之：__ 

就是之前的查询方式是根据 `驱动表` 中匹配出来的数据，让 `被驱动表` 进行一条一条的匹配，匹配完成，就会将加载到内存的那 `一条驱动表数据` 和 `被驱动表数据` 进行清空，然后再加载另外 `一条驱动表` 中的数据和 `被驱动表数据` 到内存中，然后再进行匹配，重复执行，直到 `驱动表` 中的数据被匹配完，我们可以看到这是`一次加载一条驱动表数据和所有被驱动表数据进行匹配` ，速度很慢，而且 `I/O` 很高，所以引入了一个叫做 `join buffer` 的固定大小内存，`一次性将多条驱动表数据进行加载，让被驱动表进行多条数据的匹配`，减小 `I/O`。

__详细说明：__ 

当进行 `嵌套循环连接` 时，如果数据量很大，内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前边记录的时候后边的记录可能还在磁盘上，等扫描到后边记录的时候可能内存不足，所以需要把前边的记录从内存中释放掉。我们前边又说过，采用 `嵌套循环连接算法` 的两表连接过程中，`被驱动表` 可是要被访问好多次的，如果这个 `被驱动表` 中的数据特别多而且不能使用索引进行访问，那就相当于要从磁盘上读好几次这个表，这个 `I/O` 代价就非常大了，所以我们得想办法：`尽量减少访问被驱动表的次数`。

每次访问被驱动表，被驱动表的记录会被加载到内存中，在内存中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记录，再一次把被驱动表的记录加载到内存中一遍，周而复始，驱动表结果集中有多少条记录，就得把被驱动表从磁盘上加载到内存中多少次。当数据非常多时将十分消耗资源， `基于块的嵌套循环连接` 就是 `MySQL` 会实现申请一块 (`join buffer`) 固定大小的内存，它会将多条驱动表中的记录加载到该块 (`join buffer`) 中， 每一条被驱动表的记录一次性和 `join buffer` 中的多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的 `I/O代价`，那么就实现了 `一次性和多条驱动表中的记录做匹配，这大大减少重复从磁盘上加载被驱动表的代价`。


`join buffer` 的默认大小为：256KB，最小可以设置为128字节。

*   可以通过调整`启动参数`或者`系统变量`：`join_buffer_size` 来调整大小

*   当自己的机器的内存也比较大可以尝试调大 `join_buffer_size` 的值来对连接查询进行优化。


__另外需要注意的是：__ 驱动表的记录并不是所有列都会被放到 `join buffer` 中，只有`查询列表中的列`和`过滤条件中的列`才会被放到 `join buffer` 中，所以再次提醒我们，最好不要把 `*` 作为查询列表，`只需要把我们关心的列放到查询列表就好了`，这样还可以在 `join buffer` 中放置更多的记录。



