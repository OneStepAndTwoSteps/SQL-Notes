# MySQL InnoDB数据页结构

## 页目录 (Page Directory)

当我们想根据主键值查找页中的某条记录，页目录就发挥了巨大的作用。

`页目录` 有一个别名叫做 `索引`。

### 页目录的制作过程

*   1、将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。

*   2、每个组的最后一条记录（也就是`组内最大的那条记录`）的头信息中的 n_owned 属性表示该记录拥有多少条记录，也就是该组内共有几条记录(`组内最小记录`的n_owned为1)。

*   3、将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory，也就是页目录。页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。

    *   比如：在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。`这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量`。


    `注意`：每个分组中的记录条数是有规定的：`对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。`

### 根据主键进行查询的过程

比如我们现在有5个槽的编号分别是：0、1、2、3、4，所以初始情况下最低的槽就是low=0，最高的槽就是high=4。比方说我们想找主键值为6的记录，过程是这样的：

*   1、计算中间槽的位置：`(0+4)/2=2`，所以查看`槽2`对应记录的主键值为`8`，又因为`8 > 6`，所以设置`high=2`，`low`保持不变。

*   2、重新计算中间槽的位置：`(0+2)/2=1`，所以查看`槽1`对应的主键值为`4`，又因为`4 < 6`，所以设置`low=1`，`high`保持不变。

*   3、因为`high - low`的值为`1`，所以确定主键值为`6`的记录在`槽2`对应的组中。此刻我们需要找到`槽2`中主键值最小的那条记录，然后沿着单向链表遍历`槽2`中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里`槽2`对应的记录是主键值为`8`的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到`槽1`对应的记录（主键值为`4`），该条记录的下一条记录就是`槽2`中主键值最小的记录，该记录的主键值为`5`。所以我们可以从这条主键值为`5`的记录出发，遍历`槽2`中的各条记录，直到找到主键值为`6`的那条记录即可。由于一个组中包含的记录条数只能是`1~8`条，所以遍历一个组中的记录的代价是很小的。

__所以在一个数据页中查找指定主键值的记录的过程分为两步：__

*   1、`通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。`

*   2、`通过记录的next_record属性遍历该槽所在的组中的各个记录。`


## InnoDB 是如何存储表数据的

*  `InnoDB`其实是使用`页`为基本单位来管理存储空间的，默认的页大小为`16KB`。

*  对于`InnoDB`存储引擎来说，每个索引都对应着一棵`B+树`，该`B+树`的每个节点都是一个数据`页`，数据页之间`不必要是物理连续`的，因为数据页之间有`双向链表`来维护着这些页的顺序。

*  `InnoDB`的`聚簇索引`的叶子节点存储了`完整`的用户记录，也就是所谓的`索引即数据，数据即索引`。

为了更好的管理这些`页`，`InnoDB`提出一个`表空间`或者`文件空间`（英文名：`table space`或者`file space`）的概念，这个`表空间`是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个`表空间`可以被划分为很多很多很多个页，我们的表数据就存放在某个`表空间`下的某些页里。


### InnoDB的系统表空间和独立表空间

用于更好的管理页，InnoDB 中有一个表空间的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个表空间可以被划分为很多很多很多个页，我们的表数据就存放在某个表空间下的某些页里。

    表名.frm: 描述表结构文件，字段长度等

    表名.idb: 存储数据信息和索引信息 (当使用独立表空间时会生成)


*   `系统表空间`：可以对应文件系统上一个或多个实际的文件，默认情况下，`InnoDB`会在数据目录下创建一个名为`ibdata1`、大小为`12M`的文件，这个文件就是对应的系统表空间在`文件系统`上的表示。当存储的文件大小大于`12M`时，它会进行`自扩展`。

    注：在`MySQL5.5.7` 到 `MySQL5.6.6` 之间的各个版本中，我们表中的数据都会被默认存储到这个 `系统表空间`。

*   `独立表空间`：在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。

*   `可以自行配置是否使用独立表空间`：

        [server]
        innodb_file_per_table=0 或者 1  # 当为 0 时，使用系统表空间，为 1 时使用独立表空间

除了除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用表空间（general tablespace）、undo表空间（undo tablespace）、临时表空间（temporary tablespace）等等。




## InnoDB 存储引擎的 B+ 树索引

*  每个索引都对应一棵`B+树`，`B+树`分为好多层，最下边一层是`叶子节点`，其余的是`内节点`。所有用户记录都存储在`B+树`的`叶子节点`，所有`目录项`记录都存储在`内节点`。

*  InnoDB存储引擎会自动为`主键`（如果没有它会自动帮我们添加）建立`聚簇索引`，聚簇索引的叶子节点包含完整的用户记录,`当我们没有指定主键时，MySQL会将隐藏列 row_id 作为我们的主键`。

*  我们可以为自己感兴趣的列建立`二级索引`，`二级索引`的`叶子节`点包含的用户记录由 `索引列 + 主键` 组成，所以如果想通过`二级索引`来查找完整的用户记录的话，需要通过`回表`操作，也就是在通过`二级索引`找到`主键值`之后再到`聚簇索引`中查找完整的用户记录。

*  `B+树`中每层`节点`都是按照索引列值从小到大的顺序排序而组成了`双向链表`，而且每个`页内的记录`（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个`单链表`。如果是`联合索引`的话，则页面和记录先按照`联合索引`前边的列排序，如果该列值相同，再按照`联合索引`后边的列排序。

*  通过索引查找记录是从`B+树`的`根节点`开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了`Page Directory（页目录）`，所以在这些页面中的查找非常快。







