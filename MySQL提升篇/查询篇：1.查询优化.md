# 查询篇：MySQL查询优化

## 单表查询优化

如何优化查询呢？简单来说就是 减少 `“随机IO”` 增加 `“顺序IO”`。

所以针对 `二级索引` 来说，以下的查询优化，就是通过`等值匹配`，匹配出相同的值，在相同值中，是根据`主键`的大小来排序的，此时我们就可以得到排序好的主键，通过得到排序好的主键来进行优化查询的，主键的顺序一致，那么就可以采用`顺序IO`，的方式来进行查询，这样就可以减小`回表`时的`代价`。

### 创建表

    CREATE TABLE single_table (
        id INT NOT NULL AUTO_INCREMENT,
        key1 VARCHAR(100),
        key2 INT,
        key3 VARCHAR(100),
        key_part1 VARCHAR(100),
        key_part2 VARCHAR(100),
        key_part3 VARCHAR(100),
        common_field VARCHAR(100),
        PRIMARY KEY (id),
        KEY idx_key1 (key1),
        UNIQUE KEY idx_key2 (key2),
        KEY idx_key3 (key3),
        KEY idx_key_part(key_part1, key_part2, key_part3)
    ) Engine=InnoDB CHARSET=utf8;


### 访问方法：

查询语句本身是一种声明式的语法，只是告诉MySQL获取数据的规则，背地里通过什么访问方法进行查询是MySQL自己的事，但是不同的访问方法决定了查询的速度，对于单个表的查询来说，MySQL把查询的执行方式大致分为下边两种：

*   使用全表扫描进行查询

*   使用索引进行查询

    因为直接使用全表扫描的方式执行查询要遍历好多记录，代价太大。如果查询语句中的搜索条件可以使用到某个索引，那直接使用索引来执行查询可能会加快查询执行的时间。使用索引来执行查询的方式五花八门，又可以细分为许多种类：

    *   针对主键或唯一二级索引的`等值查询`

    *   针对普通二级索引的`等值查询`

    *   针对索引列的范围查询

    *   直接扫描整个索引


#### 1、const 访问方法


`const` 速度排名：No.1

意思是常数级别的，代价是可以忽略不计的。

`const` 访问方法`只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较`，这个 `const` 访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录），如：

    SELECT * FROM single_table WHERE id = 1438;

    SELECT * FROM single_table WHERE key2 = 3841;

`注意`：对于唯一二级索引来说，查询该列为 `NULL` 值的情况比较特殊，比如这样：

    SELECT * FROM single_table WHERE key2 IS NULL;

因为唯一二级索引列并不限制 `NULL` 值的数量，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可以使用 `const` 访问方法来执行。


特点：通过 `唯一索引` 定位唯一的一条的记录。


#### 2、ref 访问方法

如该查询

    SELECT * FROM single_table WHERE key1 = 'abc';

对于该查询，可以使用全表扫描，也可以先用 `二级索引` 定位找到对应的 主键 `id` ,然后再进行回表，在聚簇索引中找到完整的记录，但是因为 `普通二级索引` 不具有唯一性的条件，所以可能找到多条匹配值，那么也就是 `对于二级索引来说，它的执行代价就取决于匹配到的二级索引的记录条目，如果条目较少，则进行回表时的代价较小` ，此时MySQL的查询优化器就使用索引来进行查询而不是使用全表扫描。

*   二级索引列值为 `NULL` 的情况

    不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含NULL值的数量并不限制，所以我们采用key IS NULL这种形式的搜索条件最多只能使用ref的访问方法，而不是const的访问方法。

*   对于联合索引来说，它的索引列也需要全部进行 `等值匹配` 否则无法使用 `ref` 。

MySQL把搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为：ref。


#### 3、ref_or_null 访问方法

当对普通二级索引进行等值匹配，并且进行 NULL 值的查询时，如：

    SELECT * FROM single_table WHERE key1 = 'abc' OR key1 IS NULL;

此时使用 `二级索引` 而不是 `全表扫描` 的方式执行该查询时，这种类型的查询使用的访问方法就称为 `ref_or_null` 。


#### 4、range 访问方法

当进行更复杂的匹配时，如：

    SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);

该查询语句，可以使用 `全表扫描` 也可以使用 `二级索引 + 回表` 的形式来进行查询。如果采用 `二级索引 + 回表` 的方式来执行的话，那么此时的搜索条件就不只是要求索引列与常数的等值匹配了，而是索引列需要匹配某个或某些范围的值，在本查询中 `key2` 列的值只要匹配下列3个范围中的任何一个就算是匹配成功了：

*   `key2`的值是`1438`

*   `key2`的值是`6328`

*   `key2`的值在`38`和`79`之间。

这种利用 `索引` (包括聚簇索引和二级索引) 进行 `范围匹配` 的访问方法称之为：`range`

#### 5、index 访问方法

如该查询语句：

    SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';

由于`key_part2`并不是联合索引`idx_key_part`最左索引列，所以我们无法使用`ref`或者`range`访问方法来执行这个语句。但是这个查询符合下边这两个条件：

*   它的查询列表只有3个列：`key_part1`, `key_part2`, `key_part3`，而索引 `idx_key_part` 又包含这三个列。

*   搜索条件中只有 `key_part2` 列。这个列也包含在索引 `idx_key_part` 中。

也就是说我们可以直接通过遍历 `idx_key_part` 索引的叶子节点的记录来比较 `key_part2 = 'abc'` 这个条件是否成立，把匹配成功的二级索引记录的 `key_part1` , `key_part2` , `key_part3` 列的值直接加到结果集中就行了。

这种采用遍历二级索引记录的执行方式称之为：`index`。

#### 6、all 访问方法

全表扫描，直接扫描 `聚簇索引`。


## 二级索引 + 回表

当我们通过二级索引进行查询时，如：

    SELECT * FROM single_table WHERE key1 = 'abc' AND key2 > 1000;

在 WHERE 的子句中，有两个条件：
    
*   `key1 = 'abc'`

*   `key2 > 1000`

先讨论执行一个查询只会用到`单个二级索引`的情况：

*   MySQL优化器根据 `single_table` 表中的记录来进行判断，使用 `key1 = 'abc'` 条件的回表更小还是使用 `key2 > 1000` 的回表更小，一般来说范围查找比等值匹配回表的条目较少，好，此时假如 `key1 = 'abc'` 的代价更小，那么我们会进行如下的操作步骤：

    *   步骤1：使用二级索引定位记录的阶段，也就是根据条件 `key1 = 'abc'` 从 `idx_key1` 索引代表的 `B+` 树中找到对应的 `二级索引记录`。

    *   步骤2：`回表阶段` ，也就是根据上一步骤中找到的记录的主键值进行 `回表` 操作，也就是到聚簇索引中找到对应的完整的用户记录，再根据条件 `key2 > 1000` 到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户。

### 对于 range 访问方法 使用的范围区间

其实对于B+树索引来说，只要索引列和常数使用 `=`、`<=>`、`IN`、`NOT IN`、`IS NULL`、`IS NOT NULL`、`>`、`<`、`>=`、`<=`、`BETWEEN`、`!=`（不等于也可以写成`<>`）或者`LIKE`操作符连接起来，就可以产生一个所谓的`区间`。


在日常的工作中，我们可能经常需要使用 `AND` 或者 `OR` 操作符连接起来。

*   AND 逻辑与: `cond1 AND cond2`：只有当`cond1`和`cond2`都为`TRUE`时整个表达式才为`TRUE`。

*   OR  逻辑或: `cond1 OR cond2`：  只要`cond1`或者`cond2`中有一个为`TRUE`整个表达式就为`TRUE`。


#### 1、所有搜索条件都可以使用某个索引的情况

当我们想使用 `range` 访问方法来执行一个查询语句时，重点就是找出该查询可用的索引以及这些索引对应的范围区间。下边分两种情况看一下怎么从由 `AND` 或 `OR` 组成的复杂搜索条件中提取出正确的 `范围区间`。

如：

    SELECT * FROM single_table WHERE key2 > 100 AND key2 > 200;

对于这样的查询，我们觉得很无语，我们能发现对于这个查询中的搜索条件都可以使用到 `key2` 相当于取两个范围区间的 `交集`，也就是`key2 > 200`。

如：

    SELECT * FROM single_table WHERE key2 > 100 OR key2 > 200;

我们能发现对于这个查询中的搜索条件都可以使用到 `key2` 相当于取两个范围区间的 `并集`,也就是 `(100， +∞)`。

#### 2、有的搜索条件无法使用索引的情况

`2.1、`比如下边这个 `AND` 查询 ：

    SELECT * FROM single_table WHERE key2 > 100 AND common_field = 'abc';

在该查询语句中，只有 `key2` 做了索引，`common_field` 没有做索引，所以在使用二级索引 `idx_key2` 定位记录的阶段用不到`common_field = 'abc'` 这个条件，这个条件是在回表获取了完整的用户记录后才能被使用。

这里我们将用不到索引的搜索条件替换为 `TRUE` ,因为我们不打算让它在该索引上进行过滤，而是在回表后进行过滤，此时将查询语句改为：

    SELECT * FROM single_table WHERE key2 > 100 AND TRUE;

化简之后就是这样：

    SELECT * FROM single_table WHERE key2 > 100;


`2.2、`再来看一下使用 `OR` 的情况：

    SELECT * FROM single_table WHERE key2 > 100 OR common_field = 'abc';

同理，我们把使用不到 `idx_key2` 索引的搜索条件替换为 `TRUE`：

    SELECT * FROM single_table WHERE key2 > 100 OR TRUE;

接着化简(因为 `OR` 是取并集)：

    SELECT * FROM single_table WHERE TRUE;

这也就说说明如果我们强制使用 `idx_key2` 执行查询的话，对应的范围区间就是`(-∞, +∞)`，也就是需要将`全部二级索引`的记录进行`回表`，这个代价肯定比直接全表扫描都大了。也就是说一个 `使用到索引的搜索条件` 和 `没有使用该索引的搜索条件` 使用 `OR`连接起来后是 `无法使用该索引` 的。


#### 复杂搜索条件下找出范围匹配的区间

对于复杂的查询语句，如：

    SELECT * FROM single_table WHERE 
            (key1 > 'xyz' AND key2 = 748 ) OR
            (key1 < 'abc' AND key1 > 'lmn') OR
            (key1 LIKE '%suf' AND key1 > 'zzz' AND (key2 < 8000 OR common_field = 'abc')) ;


*   首先查看 `WHERE` 子句中的搜索条件都涉及到了哪些列，哪些列可能使用到`索引`。


*   对于那些可能用到的`索引`，分析它们的 `范围区间`。

    *   对每个索引进行分析，如：假设我们使用 `idx_key1` 执行查询

        *   将除了 `idx_key1` 之外的索引内容设为 `True`:

                (key1 > 'xyz' AND TRUE ) OR
                (key1 < 'abc' AND key1 > 'lmn') OR
                (TRUE AND key1 > 'zzz' AND (TRUE OR TRUE))

        *   化简一下上边的搜索条件就是下边这样：

                (key1 > 'xyz') OR
                (key1 < 'abc' AND key1 > 'lmn') OR
                (key1 > 'zzz')

        *   替换掉永远为`TRUE`或`FALSE`的条件

            因为符合`key1 < 'abc' AND key1 > 'lmn'`永远为`FALSE`，所以上边的搜索条件可以被写成这样：

                (key1 > 'xyz') OR (key1 > 'zzz')

        *   继续化简区间

            `key1 > 'xyz'` 和 `key1 > 'zzz'` 之间使用OR操作符连接起来的，意味着要取并集，所以最终的结果化简的到的区间就是：`key1 > xyz`。也就是说：上边那个有一坨搜索条件的查询语句如果使用 idx_key1 索引执行查询的话，需要把满足`key1 > xyz`的二级索引记录都取出来，然后拿着这些记录的id再进行回表，得到完整的用户记录之后再使用其他的搜索条件进行过滤。


    *   接着在对 `idx_key2` 执行查询，做相同的分析。


### 索引合并

在使用索引进行查询的时候，有以下两种方法：
    
*   1、使用一个索引进行查询，在回表之后，对于回表的数据再进行过滤。

*   2、按照不同的搜索条件分别读取不同的二级索引，将从多个二级索引得到的主键值取交集，然后进行回表操作。

索引合并就是第二种查询方式，那么对于索引合并在`MySQL`中有三种方式：

*  1、`Intersection合并`

*  2、`Union合并`

*  3、`Sort-Union合并`

#### Intersection合并 

`Intersection`翻译过来的意思是`交集`。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下边这个查询：

    SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';

对于该查询语句：
    
*   在二级索引的`B+`树中，取出 `key1 = 'a'` 的相关记录.

*   在二级索引的`B+`树中，取出 `key3 = 'b'` 的相关记录.

*   二级索引的记录都是由`索引列 + 主键`构成的，所以我们可以计算出这两个结果集中`id`值的`交集`。

*   按照上一步生成的id值列表进行`回表`操作，也就是从`聚簇索引`中把指定`id`值的完整用户记录取出来，返回给用户。

`Intersection` 适用的条件：

*   情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须`等值匹配`，不能出现只匹配部分列的情况，如：

        SELECT * FROM single_table WHERE key1 = 'a' AND key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c';

*   情况二：`主键列可以是范围匹配`,如:

        SELECT * FROM single_table WHERE id > 100 AND key1 = 'a';

之所以在二级索引列都是等值匹配的情况下才可能使用 `Intersection` 索引合并，是因为只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的。

`优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过Intersection索引合并后需要回表的记录数大大减少时才会使用Intersection索引合并`。

#### Union合并

我们在写查询语句时经常想把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，我们说这些不同的搜索条件之间是`OR`关系,如：

    SELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b'

`Union`是`并集`的意思，适用于使用不同索引的搜索条件之间使用OR连接起来的情况。与`Intersection`索引合并类似，`MySQL`在某些特定的情况下才可能会使用到`Union`索引合并：

*   情况一：二级索引列是`等值匹配`的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。

*   情况二：`主键列可以是范围匹配`

*   情况三：使用`Intersection`索引合并的搜索条件：

    SELECT * FROM single_table WHERE key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c' OR (key1 = 'a' AND key3 = 'b');


`优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过Union索引合并后进行访问的代价比全表扫描更小时才会使用Union索引合并`。


#### Sort-Union合并

`Union`索引合并必须保证各个二级索引列在进行`等值匹配`的条件下才可能被用到,在进行`范围查询`时就无法使用`Union`索引合并，如：

    SELECT * FROM single_table WHERE key1 < 'a' OR key3 > 'z'

这是因为根据 `key1 < 'a'` 从 `idx_key1` 索引中获取的二级索引记录的主键值不是排好序的，根据 `key3 > 'z'` 从 `idx_key3` 索引中获取的二级索引记录的主键值也不是排好序的，但是`key1 < 'a'和key3 > 'z'`这两个条件又特别让我们动心，所以我们可以这样：

*   先根据`key1 < 'a'`条件从`idx_key1`二级索引中获取记录，并按照记录的主键值进行排序.

*   再根据`key3 > 'z'`条件从`idx_key3`二级索引中获取记录，并按照记录的主键值进行排序.

*   因为上述的`两个二级索引主键值都是排好序的`，剩下的操作和`Union`索引合并方式就一样了。

我们把上述这种先按照二级索引记录的主键值进行排序，之后按照`Union索引合并`方式执行的方式称之为`Sort-Union索引合并`，很显然，这种`Sort-Union索引合`并比单纯的`Union索引合并`多了一步对二级索引记录的主键值排序的过程。

